// DO NOT EDIT - Code generated by firemodel (dev).

import Foundation
import FirebaseFirestore

// MARK: - Models

// A Test is a test model.
struct TestModel {
    // The name.
    let name: String?
    // The age.
    let age: Int?
    // The number pi.
    let pi: Float?
    // The birth date.
    let birthdate: Date?
    // True if it is good.
    let isGood: Bool?
    let data: Data?
    let friend: TestModelRef?
    let location: GeoPoint?
    let colors: [String]
    let numbers: [Int]
    let bools: [Bool]
    let doubles: [Float]
    let directions: [TestEnum]
    let models: [TestStruct]
    let models2: [TestStruct]
    let modelRefs: [TestTimestampsRef]
    let meta: [String: String]
    let direction: TestEnum?
    let testFile: Pring.File?
    let url: URL?
    let nested: TestStruct?
}

struct TestTimestamps {
    let t: Int?
}

struct Test {
    let direction: TestEnum?
}


// MARK: - Structs

struct TestStruct {
    let `where`: String?
    let howMuch: Int?
    let someEnum: TestEnum?
}


// MARK: - Enums

enum TestEnum {
	// An unknown enum value with its raw string.
	case invalid(String?)
    case left
    case right
    case up
    case down
    case other(TestStruct)
}


// MARK: - Interfaces


// MARK: - References

struct TestModelCollectionRef {
	fileprivate let ref: CollectionReference
	fileprivate let client: FiremodelClient


	// MARK: - Child Ref

    func testModel(id: String) -> TestModelRef {
        return TestModelRef(ref: ref.document(id), client: client)
    }
}

extension TestModelCollectionRef: FiremodelCollectionSubscriber {
    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<TestModel>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [TestModel]()
                var diff = (additions: [FiremodelChange<TestModel>](), modifications: [FiremodelChange<TestModel>](), removals: [FiremodelChange<TestModel>]())
                for change in snap.documentChanges {
                    let model: TestModel
                    do {
                        model = try self.client.decode(TestModel.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}

struct TestModelRef {
	fileprivate let ref: DocumentReference
	fileprivate let client: FiremodelClient

	// MARK: - Parent Ref

    func parent() -> TestModelCollectionRef {
        return TestModelCollectionRef(ref: ref.parent, client: client)
    }
}

extension TestModelRef: FiremodelDocumentSubscriber {

    func subscribe(receiver publish: @escaping (FiremodelDocumentEvent<TestModel>) -> Void) -> FiremodelUnsubscriber {
        let registration = ref
            .addSnapshotListener { (snap: DocumentSnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }
                
                do {
                    let model = try self.client.decode(TestModel.self, from: snap)
                    publish(.snapshot(model, metadata: snap.metadata))
                } catch {
                    publish(.error(error))
                    return
                }
        }
        
        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}


struct TestTimestampsCollectionRef {
	fileprivate let ref: CollectionReference
	fileprivate let client: FiremodelClient


	// MARK: - Child Ref

    func testTimestamps(id: String) -> TestTimestampsRef {
        return TestTimestampsRef(ref: ref.document(id), client: client)
    }
}

extension TestTimestampsCollectionRef: FiremodelCollectionSubscriber {
    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<TestTimestamps>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [TestTimestamps]()
                var diff = (additions: [FiremodelChange<TestTimestamps>](), modifications: [FiremodelChange<TestTimestamps>](), removals: [FiremodelChange<TestTimestamps>]())
                for change in snap.documentChanges {
                    let model: TestTimestamps
                    do {
                        model = try self.client.decode(TestTimestamps.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}

struct TestTimestampsRef {
	fileprivate let ref: DocumentReference
	fileprivate let client: FiremodelClient

	// MARK: - Parent Ref

    func parent() -> TestTimestampsCollectionRef {
        return TestTimestampsCollectionRef(ref: ref.parent, client: client)
    }
}

extension TestTimestampsRef: FiremodelDocumentSubscriber {

    func subscribe(receiver publish: @escaping (FiremodelDocumentEvent<TestTimestamps>) -> Void) -> FiremodelUnsubscriber {
        let registration = ref
            .addSnapshotListener { (snap: DocumentSnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }
                
                do {
                    let model = try self.client.decode(TestTimestamps.self, from: snap)
                    publish(.snapshot(model, metadata: snap.metadata))
                } catch {
                    publish(.error(error))
                    return
                }
        }
        
        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}


struct TestCollectionRef {
	fileprivate let ref: CollectionReference
	fileprivate let client: FiremodelClient


	// MARK: - Child Ref

    func test(id: String) -> TestRef {
        return TestRef(ref: ref.document(id), client: client)
    }
}

extension TestCollectionRef: FiremodelCollectionSubscriber {
    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<Test>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [Test]()
                var diff = (additions: [FiremodelChange<Test>](), modifications: [FiremodelChange<Test>](), removals: [FiremodelChange<Test>]())
                for change in snap.documentChanges {
                    let model: Test
                    do {
                        model = try self.client.decode(Test.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}

struct TestRef {
	fileprivate let ref: DocumentReference
	fileprivate let client: FiremodelClient

	// MARK: - Parent Ref

    func parent() -> TestCollectionRef {
        return TestCollectionRef(ref: ref.parent, client: client)
    }
}

extension TestRef: FiremodelDocumentSubscriber {

    func subscribe(receiver publish: @escaping (FiremodelDocumentEvent<Test>) -> Void) -> FiremodelUnsubscriber {
        let registration = ref
            .addSnapshotListener { (snap: DocumentSnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }
                
                do {
                    let model = try self.client.decode(Test.self, from: snap)
                    publish(.snapshot(model, metadata: snap.metadata))
                } catch {
                    publish(.error(error))
                    return
                }
        }
        
        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}



// MARK: - Coding 

extension TestModel: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.name = try container.decodeIfPresent(String.self, forKey: .name)
        self.age = try container.decodeIfPresent(Int.self, forKey: .age)
        self.pi = try container.decodeIfPresent(Float.self, forKey: .pi)
        self.birthdate = try container.decodeIfPresent(Date.self, forKey: .birthdate)
        self.isGood = try container.decodeIfPresent(Bool.self, forKey: .isGood)
        self.data = try container.decodeIfPresent(Data.self, forKey: .data)
        self.friend = try container.decodeIfPresent(TestModelRef.self, forKey: .friend)
        self.location = try container.decodeIfPresent(GeoPoint.self, forKey: .location)
        self.colors =  try container.decode([String].self, forKey: .colors)
        self.numbers =  try container.decode([Int].self, forKey: .numbers)
        self.bools =  try container.decode([Bool].self, forKey: .bools)
        self.doubles =  try container.decode([Float].self, forKey: .doubles)
        self.directions =  try container.decode([TestEnum].self, forKey: .directions)
        self.models =  try container.decode([TestStruct].self, forKey: .models)
        self.models2 =  try container.decode([TestStruct].self, forKey: .models2)
        self.modelRefs =  try container.decode([TestTimestampsRef].self, forKey: .modelRefs)
        self.meta =  try container.decode([String: String].self, forKey: .meta)
		
        let directionContainer = try container.nestedContainer(keyedBy: TestEnumType.self, forKey: .direction)
        let directionValue = try container.decodeIfPresent(String.self, forKey: .direction)
        switch directionValue {
		case "LEFT":
			self.direction = .left
		case "RIGHT":
			self.direction = .right
		case "UP":
			self.direction = .up
		case "DOWN":
			self.direction = .down
		case "OTHER":
			self.direction = .other(try directionContainer.decode(TestStruct.self, forKey: TestEnumType.other))
		default:
			self.direction = .invalid(directionValue)
		}
        self.testFile = try container.decodeIfPresent(Pring.File.self, forKey: .testFile)
        self.url = try container.decodeIfPresent(URL.self, forKey: .url)
        self.nested = try container.decodeIfPresent(TestStruct.self, forKey: .nested)
    }

	// Coding keys for TestModel.
    enum CodingKeys: String, CodingKey {
		case name = "name"
		case age = "age"
		case pi = "pi"
		case birthdate = "birthdate"
		case isGood = "is_good"
		case data = "data"
		case friend = "friend"
		case location = "location"
		case colors = "colors"
		case numbers = "numbers"
		case bools = "bools"
		case doubles = "doubles"
		case directions = "directions"
		case models = "models"
		case models2 = "models_2"
		case modelRefs = "model_refs"
		case meta = "meta"
		case direction = "direction"
		case testFile = "test_file"
		case url = "url"
		case nested = "nested"
    }
    // Coding keys for the TestEnum enum’s associated value.
	enum TestEnumType: String, CodingKey {
		case left = "left"
		case right = "right"
		case up = "up"
		case down = "down"
		case other = "other"
	}
}

extension TestTimestamps: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.t = try container.decodeIfPresent(Int.self, forKey: .t)
    }

	// Coding keys for TestTimestamps.
    enum CodingKeys: String, CodingKey {
		case t = "t"
    }
}

extension Test: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let directionContainer = try container.nestedContainer(keyedBy: TestEnumType.self, forKey: .direction)
        let directionValue = try container.decodeIfPresent(String.self, forKey: .direction)
        switch directionValue {
		case "LEFT":
			self.direction = .left
		case "RIGHT":
			self.direction = .right
		case "UP":
			self.direction = .up
		case "DOWN":
			self.direction = .down
		case "OTHER":
			self.direction = .other(try directionContainer.decode(TestStruct.self, forKey: TestEnumType.other))
		default:
			self.direction = .invalid(directionValue)
		}
    }

	// Coding keys for Test.
    enum CodingKeys: String, CodingKey {
		case direction = "direction"
    }
    // Coding keys for the TestEnum enum’s associated value.
	enum TestEnumType: String, CodingKey {
		case left = "left"
		case right = "right"
		case up = "up"
		case down = "down"
		case other = "other"
	}
}


extension TestModelRef: Decodable {
    init(from decoder: Decoder) throws {
        guard let client = decoder.userInfo[firestoreClientDecodingKey] as? FiremodelClient else {
            assertionFailure("firemodel client is missing in user info")
            throw DocumentSnapshotDecodingError.firestoreClientMissing
        }
        let container = try decoder.singleValueContainer()
        self.client = client
        self.ref  = client.rawDocumentReference(try container.decode(String.self))
    }
}

extension TestTimestampsRef: Decodable {
    init(from decoder: Decoder) throws {
        guard let client = decoder.userInfo[firestoreClientDecodingKey] as? FiremodelClient else {
            assertionFailure("firemodel client is missing in user info")
            throw DocumentSnapshotDecodingError.firestoreClientMissing
        }
        let container = try decoder.singleValueContainer()
        self.client = client
        self.ref  = client.rawDocumentReference(try container.decode(String.self))
    }
}

extension TestRef: Decodable {
    init(from decoder: Decoder) throws {
        guard let client = decoder.userInfo[firestoreClientDecodingKey] as? FiremodelClient else {
            assertionFailure("firemodel client is missing in user info")
            throw DocumentSnapshotDecodingError.firestoreClientMissing
        }
        let container = try decoder.singleValueContainer()
        self.client = client
        self.ref  = client.rawDocumentReference(try container.decode(String.self))
    }
}


extension TestStruct: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.`where` = try container.decodeIfPresent(String.self, forKey: .`where`)
        self.howMuch = try container.decodeIfPresent(Int.self, forKey: .howMuch)
        let someEnumContainer = try container.nestedContainer(keyedBy: TestEnumType.self, forKey: .someEnum)
        let someEnumValue = try container.decodeIfPresent(String.self, forKey: .someEnum)
        switch someEnumValue {
		case "LEFT":
			self.someEnum = .left
		case "RIGHT":
			self.someEnum = .right
		case "UP":
			self.someEnum = .up
		case "DOWN":
			self.someEnum = .down
		case "OTHER":
			self.someEnum = .other(try someEnumContainer.decode(TestStruct.self, forKey: TestEnumType.other))
		default:
			self.someEnum = .invalid(someEnumValue)
		}
    }

	// Coding keys for TestStruct.
    enum CodingKeys: String, CodingKey {
		case `where` = "where"
		case howMuch = "how_much"
		case someEnum = "some_enum"
    }
    // Coding keys for the TestEnum enum’s associated value.
	enum TestEnumType: String, CodingKey {
		case left = "left"
		case right = "right"
		case up = "up"
		case down = "down"
		case other = "other"
	}
}



// MARK: - Client

class FiremodelClient {
    private let firestore: FirebaseFirestore.Firestore

	// Deprecated. Please use DI initializer instead.
    static func dev() -> FiremodelClient {
        let firestore = FirebaseFirestore.Firestore.firestore()
        return FiremodelClient(firestore: firestore)
    }

    init(firestore: FirebaseFirestore.Firestore) {
        self.firestore = firestore
    }

    // MARK: - Root Collections

    func testModels() -> TestModelCollectionRef {
        return TestModelCollectionRef(ref: firestore.collection("test_models"), client: self)
    }

    func testModel(id: String) -> TestModelRef {
        return TestModelRef(ref: firestore.collection("test_models").document(id), client: self)
    }

    func testTimestamps() -> TestTimestampsCollectionRef {
        return TestTimestampsCollectionRef(ref: firestore.collection("test_timestamps"), client: self)
    }

    func testTimestamps(id: String) -> TestTimestampsRef {
        return TestTimestampsRef(ref: firestore.collection("test_timestamps").document(id), client: self)
    }

    func tests() -> TestCollectionRef {
        return TestCollectionRef(ref: firestore.collection("test_timestamps"), client: self)
    }

    func test(id: String) -> TestRef {
        return TestRef(ref: firestore.collection("test_timestamps").document(id), client: self)
    }
}

// MARK: - Subscription Helpers

protocol FiremodelDocumentSubscriber {
    associatedtype DocumentType
    func subscribe(receiver publish: @escaping (FiremodelDocumentEvent<DocumentType>) -> Void) -> FiremodelUnsubscriber
}

enum FiremodelDocumentEvent<T> {
    case snapshot(_: T, metadata: SnapshotMetadata)
    case error(Error)
}

protocol FiremodelCollectionSubscriber {
    associatedtype DocumentType
    func subscribe(withQuery applyQuery: ((Query) -> Query)?,
                   receiver publish: @escaping (FiremodelCollectionEvent<DocumentType>) -> Void) -> FiremodelUnsubscriber
}

enum FiremodelCollectionEvent<T> {
    case snapshot(_: [T], diff: (additions: [FiremodelChange<T>], modifications: [FiremodelChange<T>], removals: [FiremodelChange<T>]), metadata: SnapshotMetadata)
    case error(Error)
}

struct FiremodelChange<T> {
    let document: T
    let oldIndex: UInt
    let newIndex: UInt
}

class FiremodelUnsubscriber {
    private var listenerRegistration: ListenerRegistration?
    private var unsubscribeOnDeinit: Bool = true

    fileprivate init(listenerRegistration: ListenerRegistration) {
        self.listenerRegistration = listenerRegistration
    }

    // Shared prevents the automatic unsubscribe behavior for rare cases when the listener registration is never retained.
    func shared() {
        self.unsubscribeOnDeinit = false
    }

    deinit {
        if unsubscribeOnDeinit {
            unsubscribe()
        }
    }

    func unsubscribe() {
        listenerRegistration?.remove()
        listenerRegistration = nil
    }
}


// MARK: - Decoding Helpers

extension FiremodelClient {


    fileprivate func decode<T>(_ type: T.Type, from snapshot: FirebaseFirestore.DocumentSnapshot) throws -> T where T: Decodable {
        let decoder = DocumentSnapshotDecoder(documentSnapshot: snapshot,
                                              codingPath: [],
                                              userInfo: [firestoreClientDecodingKey: self])

        return try type.init(from: decoder)
    }

    fileprivate func rawDocumentReference(_ path: String) -> DocumentReference {
        return self.firestore.document(path)
    }
}

enum FiremodelError: Error {
    case typeError
    case internalError
}

fileprivate let firestoreClientDecodingKey = CodingUserInfoKey(rawValue: "firestore")!


// MARK: - Decoder

struct DocumentSnapshotKey: CodingKey {
    let stringValue: String

    let intValue: Int? = nil

    init?(stringValue: String) {
        self.stringValue = stringValue
    }

    init?(intValue: Int) {
        return nil
    }
}

enum DocumentSnapshotDecodingError: Error {
    case firestoreClientMissing
}

struct DocumentSnapshotDecoder: Decoder {
    let documentSnapshot: DocumentSnapshot
    let codingPath: [CodingKey]
    let userInfo: [CodingUserInfoKey : Any]

    func container<Key>(keyedBy type: Key.Type) throws -> KeyedDecodingContainer<Key> where Key : CodingKey {
        return KeyedDecodingContainer(DocumentSnapshotKeyedDecodingContainerProtocol<Key>(documentSnapshot: documentSnapshot, codingPath: codingPath, userInfo: userInfo))
    }
    func singleValueContainer() throws -> SingleValueDecodingContainer {
        return DocumentSnapshotSingleValueDecodingContainer(documentSnapshot: documentSnapshot, codingPath: codingPath, userInfo: userInfo)
    }
    func unkeyedContainer() throws -> UnkeyedDecodingContainer {
        throw FiremodelError.typeError
    }
}

struct DocumentSnapshotUnkeyedDecodingContainer: UnkeyedDecodingContainer {
    let documentSnapshot: DocumentSnapshot

    let codingPath: [CodingKey]

    let userInfo: [CodingUserInfoKey: Any]

    var count: Int?

    var isAtEnd: Bool

    var currentIndex: Int

    mutating func decodeNil() throws -> Bool {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Bool.Type) throws -> Bool {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: String.Type) throws -> String {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Double.Type) throws -> Double {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Float.Type) throws -> Float {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int.Type) throws -> Int {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int8.Type) throws -> Int8 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int16.Type) throws -> Int16 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int32.Type) throws -> Int32 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int64.Type) throws -> Int64 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt.Type) throws -> UInt {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt8.Type) throws -> UInt8 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt16.Type) throws -> UInt16 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt32.Type) throws -> UInt32 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt64.Type) throws -> UInt64 {
        throw FiremodelError.internalError
    }

    mutating func decode<T>(_ type: T.Type) throws -> T where T : Decodable {
        throw FiremodelError.internalError
    }

    mutating func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : CodingKey {
        throw FiremodelError.internalError
    }

    mutating func nestedUnkeyedContainer() throws -> UnkeyedDecodingContainer {
        throw FiremodelError.internalError
    }

    mutating func superDecoder() throws -> Decoder {
        throw FiremodelError.internalError
    }
}

struct DocumentSnapshotSingleValueDecodingContainer: SingleValueDecodingContainer {
    let documentSnapshot: DocumentSnapshot
    let codingPath: [CodingKey]
    let userInfo: [CodingUserInfoKey: Any]

    func decodeNil() -> Bool {
        return false
    }

    func decode(_ type: Bool.Type) throws -> Bool {
        throw FiremodelError.internalError
    }

    func decode(_ type: String.Type) throws -> String {
        throw FiremodelError.internalError
    }

    func decode(_ type: Double.Type) throws -> Double {
        throw FiremodelError.internalError
    }

    func decode(_ type: Float.Type) throws -> Float {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int.Type) throws -> Int {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int8.Type) throws -> Int8 {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int16.Type) throws -> Int16 {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int32.Type) throws -> Int32 {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int64.Type) throws -> Int64 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt.Type) throws -> UInt {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt8.Type) throws -> UInt8 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt16.Type) throws -> UInt16 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt32.Type) throws -> UInt32 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt64.Type) throws -> UInt64 {
        throw FiremodelError.internalError
    }

    func decode<T>(_ type: T.Type) throws -> T where T : Decodable {
        throw FiremodelError.internalError
    }
}

struct DocumentSnapshotKeyedDecodingContainerProtocol<Key>: KeyedDecodingContainerProtocol where Key : CodingKey {
    let documentSnapshot: DocumentSnapshot
    let codingPath: [CodingKey]
    let userInfo: [CodingUserInfoKey: Any]

    var allKeys: [Key] {
        return Array(self.documentSnapshot.data()?.keys.compactMap { Key(stringValue: $0) } ?? [])
    }

    func contains(_ key: Key) -> Bool {
        return self.documentSnapshot.data()?.keys.contains(key.stringValue) ?? false
    }

    func decodeNil(forKey key: Key) throws -> Bool {
        return documentSnapshot.get(key.stringValue) == nil
    }

    private func primativeValue(forKey key: Key) throws -> Any {
        let fp = FieldPath(codingPath.map { $0.stringValue } + [key.stringValue])
        guard case let .some(value) = documentSnapshot.get(fp) else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: codingPath, debugDescription: "key missing"))
        }
        return value
    }

    func decode(_ type: Bool.Type, forKey key: Key) throws -> Bool {
        guard let value = try primativeValue(forKey: key) as? Bool else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: String.Type, forKey key: Key) throws -> String {
        guard let value = try primativeValue(forKey: key) as? String else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Double.Type, forKey key: Key) throws -> Double {
        guard let value = try primativeValue(forKey: key) as? Double else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Float.Type, forKey key: Key) throws -> Float {
        guard let value = try primativeValue(forKey: key) as? Float else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int.Type, forKey key: Key) throws -> Int {
        guard let value = try primativeValue(forKey: key) as? Int else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int8.Type, forKey key: Key) throws -> Int8 {
        guard let value = try primativeValue(forKey: key) as? Int8 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int16.Type, forKey key: Key) throws -> Int16 {
        guard let value = try primativeValue(forKey: key) as? Int16 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int32.Type, forKey key: Key) throws -> Int32 {
        guard let value = try primativeValue(forKey: key) as? Int32 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int64.Type, forKey key: Key) throws -> Int64 {
        guard let value = try primativeValue(forKey: key) as? Int64 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt.Type, forKey key: Key) throws -> UInt {
        guard let value = try primativeValue(forKey: key) as? UInt else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt8.Type, forKey key: Key) throws -> UInt8 {
        guard let value = try primativeValue(forKey: key) as? UInt8 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt16.Type, forKey key: Key) throws -> UInt16 {
        guard let value = try primativeValue(forKey: key) as? UInt16 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt32.Type, forKey key: Key) throws -> UInt32 {
        guard let value = try primativeValue(forKey: key) as? UInt32 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt64.Type, forKey key: Key) throws -> UInt64 {
        guard let value = try primativeValue(forKey: key) as? UInt64 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode<T>(_ type: T.Type, forKey key: Key) throws -> T where T : Decodable {
        let t = DocumentSnapshotDecoder(documentSnapshot: documentSnapshot, codingPath: codingPath + [key], userInfo: self.userInfo)
        return try type.init(from: t)
    }

    func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: Key) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : CodingKey {
        return KeyedDecodingContainer(DocumentSnapshotKeyedDecodingContainerProtocol<NestedKey>(documentSnapshot: documentSnapshot, codingPath: codingPath + [key], userInfo: userInfo))
    }

    func nestedUnkeyedContainer(forKey key: Key) throws -> UnkeyedDecodingContainer {
        guard let value = try primativeValue(forKey: key) as? [Any] else {
            throw DecodingError.typeMismatch([Any].self, DecodingError.Context(codingPath: codingPath, debugDescription: "Unexpected type for key \(key)"))
        }
        return DocumentSnapshotUnkeyedDecodingContainer(documentSnapshot: documentSnapshot, codingPath: codingPath + [key], userInfo: userInfo, count: value.count, isAtEnd: value.isEmpty, currentIndex: 0)
    }

    func superDecoder() throws -> Decoder {
        throw FiremodelError.internalError
    }

    func superDecoder(forKey key: Key) throws -> Decoder {
        throw FiremodelError.internalError
    }
}


// MARK: - Standard Types

struct GeoPoint {
  let latitude: Float
  let longitude: Float
}

