// DO NOT EDIT - Code generated by firemodel (dev).

import Foundation
import FirebaseFirestore

// MARK: - Models

// A Test is a test model.
struct TestModel {
    // The name.
    let name: String?
    // The age.
    let age: Int?
    // The number pi.
    let pi: Float?
    // The birth date.
    let birthdate: Date?
    // True if it is good.
    let isGood: Bool?
    let data: Data?
    let friend: TestModelRef?
    let location: GeoPoint?
    let colors: [String]
    let numbers: [Int]
    let bools: [Bool]
    let doubles: [Float]
    let directions: [TestEnum]
    let models: [TestStruct]
    let models2: [TestStruct]
    let modelRefs: [TestTimestampsRef]
    let meta: [String: String]
    let direction: TestEnum?
    let testFile: Pring.File?
    let url: URL?
    let nested: TestStruct?
}

struct TestTimestamps {
    let t: Int?
}

struct Test {
    let direction: TestEnum?
}


// MARK: - Structs

struct TestStruct {
    let `where`: String?
    let howMuch: Int?
    let someEnum: TestEnum?
}


// MARK: - Enums

enum TestEnum {
    case left
    case right
    case up
    case down
    case other(TestStruct)
}


// MARK: - References

struct TestModelRef: FiremodelDocumentSubscriber {
	fileprivate let ref: DocumentReference
	fileprivate let client: FiremodelClient

	// TODO: Subcollection refs.
	// TODO: Parent refs
}

struct TestModelCollectionRef: FiremodelCollectionSubscriber {
	fileprivate let ref: DocumentReference
	fileprivate let client: FiremodelClient

	// TODO: Subdoc refs
}

    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<TestModel>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [TestModel]()
                var diff = (additions: [FiremodelChange<TestModel>](), modifications: [FiremodelChange<TestModel>](), removals: [FiremodelChange<TestModel>]())
                for change in snap.documentChanges {
                    let model: TestModel
                    do {
                        model = try self.client.decode(TestModel.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}

struct TestTimestampsRef: FiremodelDocumentSubscriber {
	fileprivate let ref: DocumentReference
	fileprivate let client: FiremodelClient

	// TODO: Subcollection refs.
	// TODO: Parent refs
}

struct TestTimestampsCollectionRef: FiremodelCollectionSubscriber {
	fileprivate let ref: DocumentReference
	fileprivate let client: FiremodelClient

	// TODO: Subdoc refs
}

    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<TestTimestamps>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [TestTimestamps]()
                var diff = (additions: [FiremodelChange<TestTimestamps>](), modifications: [FiremodelChange<TestTimestamps>](), removals: [FiremodelChange<TestTimestamps>]())
                for change in snap.documentChanges {
                    let model: TestTimestamps
                    do {
                        model = try self.client.decode(TestTimestamps.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}

struct TestRef: FiremodelDocumentSubscriber {
	fileprivate let ref: DocumentReference
	fileprivate let client: FiremodelClient

	// TODO: Subcollection refs.
	// TODO: Parent refs
}

struct TestCollectionRef: FiremodelCollectionSubscriber {
	fileprivate let ref: DocumentReference
	fileprivate let client: FiremodelClient

	// TODO: Subdoc refs
}

    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<Test>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [Test]()
                var diff = (additions: [FiremodelChange<Test>](), modifications: [FiremodelChange<Test>](), removals: [FiremodelChange<Test>]())
                for change in snap.documentChanges {
                    let model: Test
                    do {
                        model = try self.client.decode(Test.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}


// MARK: - Coding 

extension TestModel: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.name = try container.decodeIfPresent(String.self, forKey: .name)
        self.age = try container.decodeIfPresent(Int.self, forKey: .age)
        self.pi = try container.decodeIfPresent(Float.self, forKey: .pi)
        self.birthdate = try container.decodeIfPresent(Date.self, forKey: .birthdate)
        self.isGood = try container.decodeIfPresent(Bool.self, forKey: .isGood)
        self.data = try container.decodeIfPresent(Data.self, forKey: .data)
        self.friend = try container.decodeIfPresent(TestModelRef.self, forKey: .friend)
        self.location = try container.decodeIfPresent(GeoPoint.self, forKey: .location)
        self.colors =  try container.decodeIfPresent([String])
		
        self.numbers =  try container.decodeIfPresent([Int])
		
        self.bools =  try container.decodeIfPresent([Bool])
		
        self.doubles =  try container.decodeIfPresent([Float])
		
        self.directions =  try container.decodeIfPresent([TestEnum])
		
        self.models =  try container.decodeIfPresent([TestStruct])
		
        self.models2 =  try container.decodeIfPresent([TestStruct])
		
        self.modelRefs =  try container.decodeIfPresent([TestTimestampsRef])
		
        self.meta = try container.decodeIfPresent([String: String].self, forKey: .meta)
        let directionType = try container.decodeIfPresent(String.self, forKey: .direction)
        let direction = try container.nestedContainer(keyedBy: TestEnumType.self, forKey: .direction)
		switch directionType {
		case TestEnum.other.rawValue:
		self.other = try container.decodeIfPresent(TestStruct.self, forKey: .other)
		default:
			break
		}
        self.testFile = try container.decodeIfPresent(Pring.File.self, forKey: .testFile)
        self.url = try container.decodeIfPresent(URL.self, forKey: .url)
        self.nested = try container.decodeIfPresent(TestStruct.self, forKey: .nested)
    }

	// Coding keys for TestModel.
    enum CodingKeys: String, CodingKey {
		case name = "name"
		case age = "age"
		case pi = "pi"
		case birthdate = "birthdate"
		case isGood = "is_good"
		case data = "data"
		case friend = "friend"
		case location = "location"
		case colors = "colors"
		case numbers = "numbers"
		case bools = "bools"
		case doubles = "doubles"
		case directions = "directions"
		case models = "models"
		case models2 = "models_2"
		case modelRefs = "model_refs"
		case meta = "meta"
		case direction = "direction"
		case testFile = "test_file"
		case url = "url"
		case nested = "nested"
    }
    // Coding keys for the TestEnum enum’s associated value.
	enum TestEnumType: String, CodingKey {
		case left = "left"
		case right = "right"
		case up = "up"
		case down = "down"
		case other = "other"
	}
}

extension TestTimestamps: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.t = try container.decodeIfPresent(Int.self, forKey: .t)
    }

	// Coding keys for TestTimestamps.
    enum CodingKeys: String, CodingKey {
		case t = "t"
    }
}

extension Test: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let directionType = try container.decodeIfPresent(String.self, forKey: .direction)
        let direction = try container.nestedContainer(keyedBy: TestEnumType.self, forKey: .direction)
		switch directionType {
		case TestEnum.other.rawValue:
		self.other = try container.decodeIfPresent(TestStruct.self, forKey: .other)
		default:
			break
		}
    }

	// Coding keys for Test.
    enum CodingKeys: String, CodingKey {
		case direction = "direction"
    }
    // Coding keys for the TestEnum enum’s associated value.
	enum TestEnumType: String, CodingKey {
		case left = "left"
		case right = "right"
		case up = "up"
		case down = "down"
		case other = "other"
	}
}


extension TestStruct: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.`where` = try container.decodeIfPresent(String.self, forKey: .`where`)
        self.howMuch = try container.decodeIfPresent(Int.self, forKey: .howMuch)
        let someEnumType = try container.decodeIfPresent(String.self, forKey: .someEnum)
        let someEnum = try container.nestedContainer(keyedBy: TestEnumType.self, forKey: .someEnum)
		switch someEnumType {
		case TestEnum.other.rawValue:
		self.other = try container.decodeIfPresent(TestStruct.self, forKey: .other)
		default:
			break
		}
    }

	// Coding keys for TestStruct.
    enum CodingKeys: String, CodingKey {
		case `where` = "where"
		case howMuch = "how_much"
		case someEnum = "some_enum"
    }
    // Coding keys for the TestEnum enum’s associated value.
	enum TestEnumType: String, CodingKey {
		case left = "left"
		case right = "right"
		case up = "up"
		case down = "down"
		case other = "other"
	}
}




typealias Source = FirebaseFirestore.FirestoreSource

// MARK: - Protocols

protocol FiremodelDocumentSubscriber {
    associatedtype DocumentType
    func subscribe(receiver publish: @escaping (FiremodelDocumentEvent<DocumentType>) -> Void) -> FiremodelUnsubscriber
}

enum FiremodelDocumentEvent<T> {
    case snapshot(_: T, metadata: SnapshotMetadata)
    case error(Error)
}

protocol FiremodelCollectionSubscriber {
    associatedtype DocumentType
    func subscribe(withQuery applyQuery: ((Query) -> Query)?,
                   receiver publish: @escaping (FiremodelCollectionEvent<DocumentType>) -> Void) -> FiremodelUnsubscriber
}

class FiremodelUnsubscriber {
    private var listenerRegistration: ListenerRegistration?
    private var unsubscribeOnDeinit: Bool = true

    fileprivate init(listenerRegistration: ListenerRegistration) {
        self.listenerRegistration = listenerRegistration
    }

    // Shared prevents the automatic unsubscribe behavior for rare cases when the listener registration is never retained.
    func shared() {
        self.unsubscribeOnDeinit = false
    }

    deinit {
        if unsubscribeOnDeinit {
            unsubscribe()
        }
    }

    func unsubscribe() {
        listenerRegistration?.remove()
        listenerRegistration = nil
    }
}

enum FiremodelCollectionEvent<T> {
    case snapshot(_: [T], diff: (additions: [FiremodelChange<T>], modifications: [FiremodelChange<T>], removals: [FiremodelChange<T>]), metadata: SnapshotMetadata)
    case error(Error)
}

struct FiremodelChange<T> {
    let document: T
    let oldIndex: UInt
    let newIndex: UInt
}

// MARK: - Client

class FiremodelClient {
    private let firestore: FirebaseFirestore.Firestore

    static func dev() -> FiremodelClient {
        let firestore = FirebaseFirestore.Firestore.firestore()
        return FiremodelClient(firestore: firestore)
    }

    init(firestore: FirebaseFirestore.Firestore) {
        self.firestore = firestore
    }

    // MARK: - Root Collections

    func users() -> UserCollectionRef {
        return UserCollectionRef(ref: firestore.collection("users"), client: self)
    }

    func user(id: String) -> UserRef {
        return users().user(id: id)
    }

    // MARK: - Decoding

    func decode<T>(_ type: T.Type, from snapshot: FirebaseFirestore.DocumentSnapshot) throws -> T where T: Decodable {
        let decoder = DocumentSnapshotDecoder(documentSnapshot: snapshot,
                                              codingPath: [],
                                              userInfo: [firestoreClientDecodingKey: self])

        return try type.init(from: decoder)
    }

    func rawDocumentReference(_ path: String) -> DocumentReference {
        return self.firestore.document(path)
    }
}

fileprivate let firestoreClientDecodingKey = CodingUserInfoKey(rawValue: "firestore")!


// MARK: - Decoder

struct DocumentSnapshotKey: CodingKey {
    let stringValue: String

    let intValue: Int? = nil

    init?(stringValue: String) {
        self.stringValue = stringValue
    }

    init?(intValue: Int) {
        return nil
    }
}

enum DocumentSnapshotDecodingError: Error {
    case firestoreClientMissing
}

struct DocumentSnapshotDecoder: Decoder {
    let documentSnapshot: DocumentSnapshot
    let codingPath: [CodingKey]
    let userInfo: [CodingUserInfoKey : Any]

    func container<Key>(keyedBy type: Key.Type) throws -> KeyedDecodingContainer<Key> where Key : CodingKey {
        return KeyedDecodingContainer(DocumentSnapshotKeyedDecodingContainerProtocol<Key>(documentSnapshot: documentSnapshot, codingPath: codingPath, userInfo: userInfo))
    }
    func singleValueContainer() throws -> SingleValueDecodingContainer {
        return DocumentSnapshotSingleValueDecodingContainer(documentSnapshot: documentSnapshot, codingPath: codingPath, userInfo: userInfo)
    }
    func unkeyedContainer() throws -> UnkeyedDecodingContainer {
        throw FiremodelError.typeError
    }
}

struct DocumentSnapshotUnkeyedDecodingContainer: UnkeyedDecodingContainer {
    let documentSnapshot: DocumentSnapshot

    let codingPath: [CodingKey]

    let userInfo: [CodingUserInfoKey: Any]

    var count: Int?

    var isAtEnd: Bool

    var currentIndex: Int

    mutating func decodeNil() throws -> Bool {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Bool.Type) throws -> Bool {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: String.Type) throws -> String {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Double.Type) throws -> Double {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Float.Type) throws -> Float {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int.Type) throws -> Int {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int8.Type) throws -> Int8 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int16.Type) throws -> Int16 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int32.Type) throws -> Int32 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int64.Type) throws -> Int64 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt.Type) throws -> UInt {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt8.Type) throws -> UInt8 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt16.Type) throws -> UInt16 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt32.Type) throws -> UInt32 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt64.Type) throws -> UInt64 {
        throw FiremodelError.internalError
    }

    mutating func decode<T>(_ type: T.Type) throws -> T where T : Decodable {
        throw FiremodelError.internalError
    }

    mutating func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : CodingKey {
        throw FiremodelError.internalError
    }

    mutating func nestedUnkeyedContainer() throws -> UnkeyedDecodingContainer {
        throw FiremodelError.internalError
    }

    mutating func superDecoder() throws -> Decoder {
        throw FiremodelError.internalError
    }
}

struct DocumentSnapshotSingleValueDecodingContainer: SingleValueDecodingContainer {
    let documentSnapshot: DocumentSnapshot
    let codingPath: [CodingKey]
    let userInfo: [CodingUserInfoKey: Any]

    func decodeNil() -> Bool {
        return false
    }

    func decode(_ type: Bool.Type) throws -> Bool {
        throw FiremodelError.internalError
    }

    func decode(_ type: String.Type) throws -> String {
        throw FiremodelError.internalError
    }

    func decode(_ type: Double.Type) throws -> Double {
        throw FiremodelError.internalError
    }

    func decode(_ type: Float.Type) throws -> Float {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int.Type) throws -> Int {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int8.Type) throws -> Int8 {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int16.Type) throws -> Int16 {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int32.Type) throws -> Int32 {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int64.Type) throws -> Int64 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt.Type) throws -> UInt {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt8.Type) throws -> UInt8 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt16.Type) throws -> UInt16 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt32.Type) throws -> UInt32 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt64.Type) throws -> UInt64 {
        throw FiremodelError.internalError
    }

    func decode<T>(_ type: T.Type) throws -> T where T : Decodable {
        throw FiremodelError.internalError
    }
}

struct DocumentSnapshotKeyedDecodingContainerProtocol<Key>: KeyedDecodingContainerProtocol where Key : CodingKey {
    let documentSnapshot: DocumentSnapshot
    let codingPath: [CodingKey]
    let userInfo: [CodingUserInfoKey: Any]

    var allKeys: [Key] {
        return Array(self.documentSnapshot.data()?.keys.compactMap { Key(stringValue: $0) } ?? [])
    }

    func contains(_ key: Key) -> Bool {
        return self.documentSnapshot.data()?.keys.contains(key.stringValue) ?? false
    }

    func decodeNil(forKey key: Key) throws -> Bool {
        return documentSnapshot.get(key.stringValue) == nil
    }

    private func primativeValue(forKey key: Key) throws -> Any {
        let fp = FieldPath(codingPath.map { $0.stringValue } + [key.stringValue])
        guard case let .some(value) = documentSnapshot.get(fp) else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: codingPath, debugDescription: "key missing"))
        }
        return value
    }

    func decode(_ type: Bool.Type, forKey key: Key) throws -> Bool {
        guard let value = try primativeValue(forKey: key) as? Bool else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: String.Type, forKey key: Key) throws -> String {
        guard let value = try primativeValue(forKey: key) as? String else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Double.Type, forKey key: Key) throws -> Double {
        guard let value = try primativeValue(forKey: key) as? Double else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Float.Type, forKey key: Key) throws -> Float {
        guard let value = try primativeValue(forKey: key) as? Float else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int.Type, forKey key: Key) throws -> Int {
        guard let value = try primativeValue(forKey: key) as? Int else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int8.Type, forKey key: Key) throws -> Int8 {
        guard let value = try primativeValue(forKey: key) as? Int8 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int16.Type, forKey key: Key) throws -> Int16 {
        guard let value = try primativeValue(forKey: key) as? Int16 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int32.Type, forKey key: Key) throws -> Int32 {
        guard let value = try primativeValue(forKey: key) as? Int32 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int64.Type, forKey key: Key) throws -> Int64 {
        guard let value = try primativeValue(forKey: key) as? Int64 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt.Type, forKey key: Key) throws -> UInt {
        guard let value = try primativeValue(forKey: key) as? UInt else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt8.Type, forKey key: Key) throws -> UInt8 {
        guard let value = try primativeValue(forKey: key) as? UInt8 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt16.Type, forKey key: Key) throws -> UInt16 {
        guard let value = try primativeValue(forKey: key) as? UInt16 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt32.Type, forKey key: Key) throws -> UInt32 {
        guard let value = try primativeValue(forKey: key) as? UInt32 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt64.Type, forKey key: Key) throws -> UInt64 {
        guard let value = try primativeValue(forKey: key) as? UInt64 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode<T>(_ type: T.Type, forKey key: Key) throws -> T where T : Decodable {
        let t = DocumentSnapshotDecoder(documentSnapshot: documentSnapshot, codingPath: codingPath + [key], userInfo: self.userInfo)
        return try type.init(from: t)
    }

    func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: Key) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : CodingKey {
        return KeyedDecodingContainer(DocumentSnapshotKeyedDecodingContainerProtocol<NestedKey>(documentSnapshot: documentSnapshot, codingPath: codingPath + [key], userInfo: userInfo))
    }

    func nestedUnkeyedContainer(forKey key: Key) throws -> UnkeyedDecodingContainer {
        guard let value = try primativeValue(forKey: key) as? [Any] else {
            throw DecodingError.typeMismatch([Any].self, DecodingError.Context(codingPath: codingPath, debugDescription: "Unexpected type for key \(key)"))
        }
        return DocumentSnapshotUnkeyedDecodingContainer(documentSnapshot: documentSnapshot, codingPath: codingPath + [key], userInfo: userInfo, count: value.count, isAtEnd: value.isEmpty, currentIndex: 0)
    }

    func superDecoder() throws -> Decoder {
        throw FiremodelError.internalError
    }

    func superDecoder(forKey key: Key) throws -> Decoder {
        throw FiremodelError.internalError
    }
}


// MARK: - Protocols 

// MARK: - Standard Types

struct GeoPoint {
  let latitude: Float
  let longitude: Float
}

