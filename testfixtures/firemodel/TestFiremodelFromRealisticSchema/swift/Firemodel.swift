// DO NOT EDIT - Code generated by firemodel (dev).

import Foundation
import FirebaseFirestore

// MARK: - Models

// [new] It is now assumed that all fields of all types (other than enums associated values) are optional. In order to facilitate queries on missing fields, missing fields are saved in firestore as explicit null values.
struct User {
    let username: String?
    let displayName: String?
    let avatar: Avatar?
}

struct LocalizedString {
    let strings: [String: String]
}

struct InstantGram {
    let sharedWith: Audience?
    let photoUrl: URL?
    let description: String?
    let tags: [String]
}

struct Message {
    let content: MessageContent?
    let from: FriendRef?
}

struct Attachment {
    let title: String?
    let content: AttachmentContent?
}

struct Friend {
    let username: String?
    let displayName: String?
    let avatar: Avatar?
    let friendsSinice: Date?
}


// MARK: - Structs

// firestore client libraries.
struct Avatar {
    let url: URL?
    let color: String?
}

struct ImojiAttachment {
    let coolPic: Data?
}

struct GramAttachment {
    let ref: String?
}

struct UploadAttachment {
    let title: String?
    let src: URL?
}

struct Upload {
    let url: URL?
    let mimeType: String?
}

struct TextMessageContent {
    let message: String?
}

struct PhotoMessageContent {
    let caption: String?
    let url: URL?
}


// MARK: - Enums

// [unchanged] Enums provide type safety around string enumerations. Enums are stored in firestore as capitalized strings.
enum Audience {
	// An unknown enum value with its raw string.
	case invalid(String?)
    case global
    case friends
}

// for enum values other than the active one are not written to firestore.
enum AttachmentContent {
	// An unknown enum value with its raw string.
	case invalid(String?)
    // e.g. for an Attachment, written as `content = "PLACEHOLDER"`
    case placeholder
    // e.g. for an Attachment, written as `content = "IMOJI", content.imoji = #BYTES#`
    case imoji(ImojiAttachment)
    // e.g. for an Attachment, written as `content = "IMOJI", content.imoji = #BYTES#`
    case gram(GramAttachment)
    // e.g. for an Attachment, written as `content = "UPLOAD", content.upload.token = "oijasdf", content.upload.etc = the_rest`
    case upload(UploadAttachment)
}

enum MessageContent {
	// An unknown enum value with its raw string.
	case invalid(String?)
    case text(TextMessageContent)
    case photo(PhotoMessageContent)
}


// MARK: - References

struct UserCollectionRef {
	fileprivate let ref: CollectionReference
	fileprivate let client: FiremodelClient


	// MARK: - Child Ref

    func user(id: String) -> UserRef {
        return UserRef(ref: ref.document(id), client: client)
    }
}

extension UserCollectionRef: FiremodelCollectionSubscriber {
    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<User>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [User]()
                var diff = (additions: [FiremodelChange<User>](), modifications: [FiremodelChange<User>](), removals: [FiremodelChange<User>]())
                for change in snap.documentChanges {
                    let model: User
                    do {
                        model = try self.client.decode(User.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}

struct UserRef {
	fileprivate let ref: DocumentReference
	fileprivate let client: FiremodelClient

	// MARK: - Parent Ref

    func parent() -> UserCollectionRef {
        return UserCollectionRef(ref: ref.parent, client: client)
    }

	// MARK: -  Subcollection Refs

    func instantGrams() -> InstantGramCollectionRef {
        return InstantGramCollectionRef(ref: ref.collection("instant_grams"), client: client)
    }

    func messages() -> MessageCollectionRef {
        return MessageCollectionRef(ref: ref.collection("messages"), client: client)
    }

    func attachments() -> AttachmentCollectionRef {
        return AttachmentCollectionRef(ref: ref.collection("attachments"), client: client)
    }

    func friends() -> FriendCollectionRef {
        return FriendCollectionRef(ref: ref.collection("friends"), client: client)
    }
}

extension UserRef: FiremodelDocumentSubscriber {

    func subscribe(receiver publish: @escaping (FiremodelDocumentEvent<User>) -> Void) -> FiremodelUnsubscriber {
        let registration = ref
            .addSnapshotListener { (snap: DocumentSnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }
                
                do {
                    let model = try self.client.decode(User.self, from: snap)
                    publish(.snapshot(model, metadata: snap.metadata))
                } catch {
                    publish(.error(error))
                    return
                }
        }
        
        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}


struct LocalizedStringCollectionRef {
	fileprivate let ref: CollectionReference
	fileprivate let client: FiremodelClient


	// MARK: - Child Ref

    func localizedString(id: String) -> LocalizedStringRef {
        return LocalizedStringRef(ref: ref.document(id), client: client)
    }
}

extension LocalizedStringCollectionRef: FiremodelCollectionSubscriber {
    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<LocalizedString>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [LocalizedString]()
                var diff = (additions: [FiremodelChange<LocalizedString>](), modifications: [FiremodelChange<LocalizedString>](), removals: [FiremodelChange<LocalizedString>]())
                for change in snap.documentChanges {
                    let model: LocalizedString
                    do {
                        model = try self.client.decode(LocalizedString.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}

struct LocalizedStringRef {
	fileprivate let ref: DocumentReference
	fileprivate let client: FiremodelClient

	// MARK: - Parent Ref

    func parent() -> LocalizedStringCollectionRef {
        return LocalizedStringCollectionRef(ref: ref.parent, client: client)
    }
}

extension LocalizedStringRef: FiremodelDocumentSubscriber {

    func subscribe(receiver publish: @escaping (FiremodelDocumentEvent<LocalizedString>) -> Void) -> FiremodelUnsubscriber {
        let registration = ref
            .addSnapshotListener { (snap: DocumentSnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }
                
                do {
                    let model = try self.client.decode(LocalizedString.self, from: snap)
                    publish(.snapshot(model, metadata: snap.metadata))
                } catch {
                    publish(.error(error))
                    return
                }
        }
        
        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}


struct InstantGramCollectionRef {
	fileprivate let ref: CollectionReference
	fileprivate let client: FiremodelClient

	// MARK: - Parent Ref

    func parent() -> UserRef {
        return UserRef(ref: ref.parent!, client: client)
    }


	// MARK: - Child Ref

    func instantGram(id: String) -> InstantGramRef {
        return InstantGramRef(ref: ref.document(id), client: client)
    }
}

extension InstantGramCollectionRef: FiremodelCollectionSubscriber {
    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<InstantGram>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [InstantGram]()
                var diff = (additions: [FiremodelChange<InstantGram>](), modifications: [FiremodelChange<InstantGram>](), removals: [FiremodelChange<InstantGram>]())
                for change in snap.documentChanges {
                    let model: InstantGram
                    do {
                        model = try self.client.decode(InstantGram.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}

struct InstantGramRef {
	fileprivate let ref: DocumentReference
	fileprivate let client: FiremodelClient

	// MARK: - Parent Ref

    func parent() -> InstantGramCollectionRef {
        return InstantGramCollectionRef(ref: ref.parent, client: client)
    }
}

extension InstantGramRef: FiremodelDocumentSubscriber {

    func subscribe(receiver publish: @escaping (FiremodelDocumentEvent<InstantGram>) -> Void) -> FiremodelUnsubscriber {
        let registration = ref
            .addSnapshotListener { (snap: DocumentSnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }
                
                do {
                    let model = try self.client.decode(InstantGram.self, from: snap)
                    publish(.snapshot(model, metadata: snap.metadata))
                } catch {
                    publish(.error(error))
                    return
                }
        }
        
        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}


struct MessageCollectionRef {
	fileprivate let ref: CollectionReference
	fileprivate let client: FiremodelClient

	// MARK: - Parent Ref

    func parent() -> UserRef {
        return UserRef(ref: ref.parent!, client: client)
    }


	// MARK: - Child Ref

    func message(id: String) -> MessageRef {
        return MessageRef(ref: ref.document(id), client: client)
    }
}

extension MessageCollectionRef: FiremodelCollectionSubscriber {
    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<Message>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [Message]()
                var diff = (additions: [FiremodelChange<Message>](), modifications: [FiremodelChange<Message>](), removals: [FiremodelChange<Message>]())
                for change in snap.documentChanges {
                    let model: Message
                    do {
                        model = try self.client.decode(Message.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}

struct MessageRef {
	fileprivate let ref: DocumentReference
	fileprivate let client: FiremodelClient

	// MARK: - Parent Ref

    func parent() -> MessageCollectionRef {
        return MessageCollectionRef(ref: ref.parent, client: client)
    }
}

extension MessageRef: FiremodelDocumentSubscriber {

    func subscribe(receiver publish: @escaping (FiremodelDocumentEvent<Message>) -> Void) -> FiremodelUnsubscriber {
        let registration = ref
            .addSnapshotListener { (snap: DocumentSnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }
                
                do {
                    let model = try self.client.decode(Message.self, from: snap)
                    publish(.snapshot(model, metadata: snap.metadata))
                } catch {
                    publish(.error(error))
                    return
                }
        }
        
        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}


struct AttachmentCollectionRef {
	fileprivate let ref: CollectionReference
	fileprivate let client: FiremodelClient

	// MARK: - Parent Ref

    func parent() -> UserRef {
        return UserRef(ref: ref.parent!, client: client)
    }


	// MARK: - Child Ref

    func attachment(id: String) -> AttachmentRef {
        return AttachmentRef(ref: ref.document(id), client: client)
    }
}

extension AttachmentCollectionRef: FiremodelCollectionSubscriber {
    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<Attachment>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [Attachment]()
                var diff = (additions: [FiremodelChange<Attachment>](), modifications: [FiremodelChange<Attachment>](), removals: [FiremodelChange<Attachment>]())
                for change in snap.documentChanges {
                    let model: Attachment
                    do {
                        model = try self.client.decode(Attachment.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}

struct AttachmentRef {
	fileprivate let ref: DocumentReference
	fileprivate let client: FiremodelClient

	// MARK: - Parent Ref

    func parent() -> AttachmentCollectionRef {
        return AttachmentCollectionRef(ref: ref.parent, client: client)
    }
}

extension AttachmentRef: FiremodelDocumentSubscriber {

    func subscribe(receiver publish: @escaping (FiremodelDocumentEvent<Attachment>) -> Void) -> FiremodelUnsubscriber {
        let registration = ref
            .addSnapshotListener { (snap: DocumentSnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }
                
                do {
                    let model = try self.client.decode(Attachment.self, from: snap)
                    publish(.snapshot(model, metadata: snap.metadata))
                } catch {
                    publish(.error(error))
                    return
                }
        }
        
        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}


struct FriendCollectionRef {
	fileprivate let ref: CollectionReference
	fileprivate let client: FiremodelClient

	// MARK: - Parent Ref

    func parent() -> UserRef {
        return UserRef(ref: ref.parent!, client: client)
    }


	// MARK: - Child Ref

    func friend(id: String) -> FriendRef {
        return FriendRef(ref: ref.document(id), client: client)
    }
}

extension FriendCollectionRef: FiremodelCollectionSubscriber {
    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<Friend>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [Friend]()
                var diff = (additions: [FiremodelChange<Friend>](), modifications: [FiremodelChange<Friend>](), removals: [FiremodelChange<Friend>]())
                for change in snap.documentChanges {
                    let model: Friend
                    do {
                        model = try self.client.decode(Friend.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}

struct FriendRef {
	fileprivate let ref: DocumentReference
	fileprivate let client: FiremodelClient

	// MARK: - Parent Ref

    func parent() -> FriendCollectionRef {
        return FriendCollectionRef(ref: ref.parent, client: client)
    }
}

extension FriendRef: FiremodelDocumentSubscriber {

    func subscribe(receiver publish: @escaping (FiremodelDocumentEvent<Friend>) -> Void) -> FiremodelUnsubscriber {
        let registration = ref
            .addSnapshotListener { (snap: DocumentSnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }
                
                do {
                    let model = try self.client.decode(Friend.self, from: snap)
                    publish(.snapshot(model, metadata: snap.metadata))
                } catch {
                    publish(.error(error))
                    return
                }
        }
        
        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}



// MARK: - Coding 

extension User: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.username = try container.decodeIfPresent(String.self, forKey: .username)
        self.displayName = try container.decodeIfPresent(String.self, forKey: .displayName)
        self.avatar = try container.decodeIfPresent(Avatar.self, forKey: .avatar)
    }

	// Coding keys for User.
    enum CodingKeys: String, CodingKey {
		case username = "username"
		case displayName = "display_name"
		case avatar = "avatar"
    }
}

extension LocalizedString: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.strings =  try container.decode([String: String].self, forKey: .strings)
		
    }

	// Coding keys for LocalizedString.
    enum CodingKeys: String, CodingKey {
		case strings = "strings"
    }
}

extension InstantGram: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let sharedWithValue = try container.decodeIfPresent(String.self, forKey: .sharedWith)
        switch sharedWithValue {
		case "GLOBAL":
			self.sharedWith = .global
		case "FRIENDS":
			self.sharedWith = .friends
		default:
			self.sharedWith = .invalid(sharedWithValue)
		}
        self.photoUrl = try container.decodeIfPresent(URL.self, forKey: .photoUrl)
        self.description = try container.decodeIfPresent(String.self, forKey: .description)
        self.tags =  try container.decode([String].self, forKey: .tags)
    }

	// Coding keys for InstantGram.
    enum CodingKeys: String, CodingKey {
		case sharedWith = "shared_with"
		case photoUrl = "photo_url"
		case description = "description"
		case tags = "tags"
    }
    // Coding keys for the Audience enum’s associated value.
	enum AudienceType: String, CodingKey {
		case global = "global"
		case friends = "friends"
	}
}

extension Message: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let contentContainer = try container.nestedContainer(keyedBy: MessageContentType.self, forKey: .content)
        let contentValue = try container.decodeIfPresent(String.self, forKey: .content)
        switch contentValue {
		case "TEXT":
			self.content = .text(try contentContainer.decode(TextMessageContent.self, forKey: MessageContentType.text))
		case "PHOTO":
			self.content = .photo(try contentContainer.decode(PhotoMessageContent.self, forKey: MessageContentType.photo))
		default:
			self.content = .invalid(contentValue)
		}
        self.from = try container.decodeIfPresent(FriendRef.self, forKey: .from)
    }

	// Coding keys for Message.
    enum CodingKeys: String, CodingKey {
		case content = "content"
		case from = "from"
    }
    // Coding keys for the MessageContent enum’s associated value.
	enum MessageContentType: String, CodingKey {
		case text = "text"
		case photo = "photo"
	}
}

extension Attachment: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.title = try container.decodeIfPresent(String.self, forKey: .title)
        let contentContainer = try container.nestedContainer(keyedBy: AttachmentContentType.self, forKey: .content)
        let contentValue = try container.decodeIfPresent(String.self, forKey: .content)
        switch contentValue {
		case "PLACEHOLDER":
			self.content = .placeholder
		case "IMOJI":
			self.content = .imoji(try contentContainer.decode(ImojiAttachment.self, forKey: AttachmentContentType.imoji))
		case "GRAM":
			self.content = .gram(try contentContainer.decode(GramAttachment.self, forKey: AttachmentContentType.gram))
		case "UPLOAD":
			self.content = .upload(try contentContainer.decode(UploadAttachment.self, forKey: AttachmentContentType.upload))
		default:
			self.content = .invalid(contentValue)
		}
    }

	// Coding keys for Attachment.
    enum CodingKeys: String, CodingKey {
		case title = "title"
		case content = "content"
    }
    // Coding keys for the AttachmentContent enum’s associated value.
	enum AttachmentContentType: String, CodingKey {
		case placeholder = "placeholder"
		case imoji = "imoji"
		case gram = "gram"
		case upload = "upload"
	}
}

extension Friend: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.username = try container.decodeIfPresent(String.self, forKey: .username)
        self.displayName = try container.decodeIfPresent(String.self, forKey: .displayName)
        self.avatar = try container.decodeIfPresent(Avatar.self, forKey: .avatar)
        self.friendsSinice = try container.decodeIfPresent(Date.self, forKey: .friendsSinice)
    }

	// Coding keys for Friend.
    enum CodingKeys: String, CodingKey {
		case username = "username"
		case displayName = "display_name"
		case avatar = "avatar"
		case friendsSinice = "friends_sinice"
    }
}


extension UserRef: Decodable {
    init(from decoder: Decoder) throws {
        guard let client = decoder.userInfo[firestoreClientDecodingKey] as? FiremodelClient else {
            assertionFailure("firemodel client is missing in user info")
            throw DocumentSnapshotDecodingError.firestoreClientMissing
        }
        let container = try decoder.singleValueContainer()
        self.client = client
        self.ref  = client.rawDocumentReference(try container.decode(String.self))
    }
}

extension LocalizedStringRef: Decodable {
    init(from decoder: Decoder) throws {
        guard let client = decoder.userInfo[firestoreClientDecodingKey] as? FiremodelClient else {
            assertionFailure("firemodel client is missing in user info")
            throw DocumentSnapshotDecodingError.firestoreClientMissing
        }
        let container = try decoder.singleValueContainer()
        self.client = client
        self.ref  = client.rawDocumentReference(try container.decode(String.self))
    }
}

extension InstantGramRef: Decodable {
    init(from decoder: Decoder) throws {
        guard let client = decoder.userInfo[firestoreClientDecodingKey] as? FiremodelClient else {
            assertionFailure("firemodel client is missing in user info")
            throw DocumentSnapshotDecodingError.firestoreClientMissing
        }
        let container = try decoder.singleValueContainer()
        self.client = client
        self.ref  = client.rawDocumentReference(try container.decode(String.self))
    }
}

extension MessageRef: Decodable {
    init(from decoder: Decoder) throws {
        guard let client = decoder.userInfo[firestoreClientDecodingKey] as? FiremodelClient else {
            assertionFailure("firemodel client is missing in user info")
            throw DocumentSnapshotDecodingError.firestoreClientMissing
        }
        let container = try decoder.singleValueContainer()
        self.client = client
        self.ref  = client.rawDocumentReference(try container.decode(String.self))
    }
}

extension AttachmentRef: Decodable {
    init(from decoder: Decoder) throws {
        guard let client = decoder.userInfo[firestoreClientDecodingKey] as? FiremodelClient else {
            assertionFailure("firemodel client is missing in user info")
            throw DocumentSnapshotDecodingError.firestoreClientMissing
        }
        let container = try decoder.singleValueContainer()
        self.client = client
        self.ref  = client.rawDocumentReference(try container.decode(String.self))
    }
}

extension FriendRef: Decodable {
    init(from decoder: Decoder) throws {
        guard let client = decoder.userInfo[firestoreClientDecodingKey] as? FiremodelClient else {
            assertionFailure("firemodel client is missing in user info")
            throw DocumentSnapshotDecodingError.firestoreClientMissing
        }
        let container = try decoder.singleValueContainer()
        self.client = client
        self.ref  = client.rawDocumentReference(try container.decode(String.self))
    }
}


extension Avatar: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.url = try container.decodeIfPresent(URL.self, forKey: .url)
        self.color = try container.decodeIfPresent(String.self, forKey: .color)
    }

	// Coding keys for Avatar.
    enum CodingKeys: String, CodingKey {
		case url = "url"
		case color = "color"
    }
}

extension ImojiAttachment: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.coolPic = try container.decodeIfPresent(Data.self, forKey: .coolPic)
    }

	// Coding keys for ImojiAttachment.
    enum CodingKeys: String, CodingKey {
		case coolPic = "cool_pic"
    }
}

extension GramAttachment: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.ref = try container.decodeIfPresent(String.self, forKey: .ref)
    }

	// Coding keys for GramAttachment.
    enum CodingKeys: String, CodingKey {
		case ref = "ref"
    }
}

extension UploadAttachment: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.title = try container.decodeIfPresent(String.self, forKey: .title)
        self.src = try container.decodeIfPresent(URL.self, forKey: .src)
    }

	// Coding keys for UploadAttachment.
    enum CodingKeys: String, CodingKey {
		case title = "title"
		case src = "src"
    }
}

extension Upload: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.url = try container.decodeIfPresent(URL.self, forKey: .url)
        self.mimeType = try container.decodeIfPresent(String.self, forKey: .mimeType)
    }

	// Coding keys for Upload.
    enum CodingKeys: String, CodingKey {
		case url = "url"
		case mimeType = "mime_type"
    }
}

extension TextMessageContent: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.message = try container.decodeIfPresent(String.self, forKey: .message)
    }

	// Coding keys for TextMessageContent.
    enum CodingKeys: String, CodingKey {
		case message = "message"
    }
}

extension PhotoMessageContent: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.caption = try container.decodeIfPresent(String.self, forKey: .caption)
        self.url = try container.decodeIfPresent(URL.self, forKey: .url)
    }

	// Coding keys for PhotoMessageContent.
    enum CodingKeys: String, CodingKey {
		case caption = "caption"
		case url = "url"
    }
}



// MARK: - Client

class FiremodelClient {
    private let firestore: FirebaseFirestore.Firestore

	// Deprecated. Please use DI initializer instead.
    static func dev() -> FiremodelClient {
        let firestore = FirebaseFirestore.Firestore.firestore()
        return FiremodelClient(firestore: firestore)
    }

    init(firestore: FirebaseFirestore.Firestore) {
        self.firestore = firestore
    }

    // MARK: - Root Collections

    func users() -> UserCollectionRef {
        return UserCollectionRef(ref: firestore.collection("users"), client: self)
    }

    func user(id: String) -> UserRef {
        return UserRef(ref: firestore.collection("users").document(id), client: self)
    }

    func localizedStrings() -> LocalizedStringCollectionRef {
        return LocalizedStringCollectionRef(ref: firestore.collection("localized_string"), client: self)
    }

    func localizedString(id: String) -> LocalizedStringRef {
        return LocalizedStringRef(ref: firestore.collection("localized_string").document(id), client: self)
    }
}

// MARK: - Subscription Helpers

protocol FiremodelDocumentSubscriber {
    associatedtype DocumentType
    func subscribe(receiver publish: @escaping (FiremodelDocumentEvent<DocumentType>) -> Void) -> FiremodelUnsubscriber
}

enum FiremodelDocumentEvent<T> {
    case snapshot(_: T, metadata: SnapshotMetadata)
    case error(Error)
}

protocol FiremodelCollectionSubscriber {
    associatedtype DocumentType
    func subscribe(withQuery applyQuery: ((Query) -> Query)?,
                   receiver publish: @escaping (FiremodelCollectionEvent<DocumentType>) -> Void) -> FiremodelUnsubscriber
}

enum FiremodelCollectionEvent<T> {
    case snapshot(_: [T], diff: (additions: [FiremodelChange<T>], modifications: [FiremodelChange<T>], removals: [FiremodelChange<T>]), metadata: SnapshotMetadata)
    case error(Error)
}

struct FiremodelChange<T> {
    let document: T
    let oldIndex: UInt
    let newIndex: UInt
}

class FiremodelUnsubscriber {
    private var listenerRegistration: ListenerRegistration?
    private var unsubscribeOnDeinit: Bool = true

    fileprivate init(listenerRegistration: ListenerRegistration) {
        self.listenerRegistration = listenerRegistration
    }

    // Shared prevents the automatic unsubscribe behavior for rare cases when the listener registration is never retained.
    func shared() {
        self.unsubscribeOnDeinit = false
    }

    deinit {
        if unsubscribeOnDeinit {
            unsubscribe()
        }
    }

    func unsubscribe() {
        listenerRegistration?.remove()
        listenerRegistration = nil
    }
}


// MARK: - Decoding Helpers

extension FiremodelClient {


    fileprivate func decode<T>(_ type: T.Type, from snapshot: FirebaseFirestore.DocumentSnapshot) throws -> T where T: Decodable {
        let decoder = DocumentSnapshotDecoder(documentSnapshot: snapshot,
                                              codingPath: [],
                                              userInfo: [firestoreClientDecodingKey: self])

        return try type.init(from: decoder)
    }

    fileprivate func rawDocumentReference(_ path: String) -> DocumentReference {
        return self.firestore.document(path)
    }
}

enum FiremodelError: Error {
    case typeError
    case internalError
}

fileprivate let firestoreClientDecodingKey = CodingUserInfoKey(rawValue: "firestore")!


// MARK: - Decoder

struct DocumentSnapshotKey: CodingKey {
    let stringValue: String

    let intValue: Int? = nil

    init?(stringValue: String) {
        self.stringValue = stringValue
    }

    init?(intValue: Int) {
        return nil
    }
}

enum DocumentSnapshotDecodingError: Error {
    case firestoreClientMissing
}

struct DocumentSnapshotDecoder: Decoder {
    let documentSnapshot: DocumentSnapshot
    let codingPath: [CodingKey]
    let userInfo: [CodingUserInfoKey : Any]

    func container<Key>(keyedBy type: Key.Type) throws -> KeyedDecodingContainer<Key> where Key : CodingKey {
        return KeyedDecodingContainer(DocumentSnapshotKeyedDecodingContainerProtocol<Key>(documentSnapshot: documentSnapshot, codingPath: codingPath, userInfo: userInfo))
    }
    func singleValueContainer() throws -> SingleValueDecodingContainer {
        return DocumentSnapshotSingleValueDecodingContainer(documentSnapshot: documentSnapshot, codingPath: codingPath, userInfo: userInfo)
    }
    func unkeyedContainer() throws -> UnkeyedDecodingContainer {
        throw FiremodelError.typeError
    }
}

struct DocumentSnapshotUnkeyedDecodingContainer: UnkeyedDecodingContainer {
    let documentSnapshot: DocumentSnapshot

    let codingPath: [CodingKey]

    let userInfo: [CodingUserInfoKey: Any]

    var count: Int?

    var isAtEnd: Bool

    var currentIndex: Int

    mutating func decodeNil() throws -> Bool {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Bool.Type) throws -> Bool {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: String.Type) throws -> String {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Double.Type) throws -> Double {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Float.Type) throws -> Float {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int.Type) throws -> Int {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int8.Type) throws -> Int8 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int16.Type) throws -> Int16 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int32.Type) throws -> Int32 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int64.Type) throws -> Int64 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt.Type) throws -> UInt {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt8.Type) throws -> UInt8 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt16.Type) throws -> UInt16 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt32.Type) throws -> UInt32 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt64.Type) throws -> UInt64 {
        throw FiremodelError.internalError
    }

    mutating func decode<T>(_ type: T.Type) throws -> T where T : Decodable {
        throw FiremodelError.internalError
    }

    mutating func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : CodingKey {
        throw FiremodelError.internalError
    }

    mutating func nestedUnkeyedContainer() throws -> UnkeyedDecodingContainer {
        throw FiremodelError.internalError
    }

    mutating func superDecoder() throws -> Decoder {
        throw FiremodelError.internalError
    }
}

struct DocumentSnapshotSingleValueDecodingContainer: SingleValueDecodingContainer {
    let documentSnapshot: DocumentSnapshot
    let codingPath: [CodingKey]
    let userInfo: [CodingUserInfoKey: Any]

    func decodeNil() -> Bool {
        return false
    }

    func decode(_ type: Bool.Type) throws -> Bool {
        throw FiremodelError.internalError
    }

    func decode(_ type: String.Type) throws -> String {
        throw FiremodelError.internalError
    }

    func decode(_ type: Double.Type) throws -> Double {
        throw FiremodelError.internalError
    }

    func decode(_ type: Float.Type) throws -> Float {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int.Type) throws -> Int {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int8.Type) throws -> Int8 {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int16.Type) throws -> Int16 {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int32.Type) throws -> Int32 {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int64.Type) throws -> Int64 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt.Type) throws -> UInt {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt8.Type) throws -> UInt8 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt16.Type) throws -> UInt16 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt32.Type) throws -> UInt32 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt64.Type) throws -> UInt64 {
        throw FiremodelError.internalError
    }

    func decode<T>(_ type: T.Type) throws -> T where T : Decodable {
        throw FiremodelError.internalError
    }
}

struct DocumentSnapshotKeyedDecodingContainerProtocol<Key>: KeyedDecodingContainerProtocol where Key : CodingKey {
    let documentSnapshot: DocumentSnapshot
    let codingPath: [CodingKey]
    let userInfo: [CodingUserInfoKey: Any]

    var allKeys: [Key] {
        return Array(self.documentSnapshot.data()?.keys.compactMap { Key(stringValue: $0) } ?? [])
    }

    func contains(_ key: Key) -> Bool {
        return self.documentSnapshot.data()?.keys.contains(key.stringValue) ?? false
    }

    func decodeNil(forKey key: Key) throws -> Bool {
        return documentSnapshot.get(key.stringValue) == nil
    }

    private func primativeValue(forKey key: Key) throws -> Any {
        let fp = FieldPath(codingPath.map { $0.stringValue } + [key.stringValue])
        guard case let .some(value) = documentSnapshot.get(fp) else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: codingPath, debugDescription: "key missing"))
        }
        return value
    }

    func decode(_ type: Bool.Type, forKey key: Key) throws -> Bool {
        guard let value = try primativeValue(forKey: key) as? Bool else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: String.Type, forKey key: Key) throws -> String {
        guard let value = try primativeValue(forKey: key) as? String else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Double.Type, forKey key: Key) throws -> Double {
        guard let value = try primativeValue(forKey: key) as? Double else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Float.Type, forKey key: Key) throws -> Float {
        guard let value = try primativeValue(forKey: key) as? Float else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int.Type, forKey key: Key) throws -> Int {
        guard let value = try primativeValue(forKey: key) as? Int else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int8.Type, forKey key: Key) throws -> Int8 {
        guard let value = try primativeValue(forKey: key) as? Int8 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int16.Type, forKey key: Key) throws -> Int16 {
        guard let value = try primativeValue(forKey: key) as? Int16 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int32.Type, forKey key: Key) throws -> Int32 {
        guard let value = try primativeValue(forKey: key) as? Int32 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int64.Type, forKey key: Key) throws -> Int64 {
        guard let value = try primativeValue(forKey: key) as? Int64 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt.Type, forKey key: Key) throws -> UInt {
        guard let value = try primativeValue(forKey: key) as? UInt else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt8.Type, forKey key: Key) throws -> UInt8 {
        guard let value = try primativeValue(forKey: key) as? UInt8 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt16.Type, forKey key: Key) throws -> UInt16 {
        guard let value = try primativeValue(forKey: key) as? UInt16 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt32.Type, forKey key: Key) throws -> UInt32 {
        guard let value = try primativeValue(forKey: key) as? UInt32 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt64.Type, forKey key: Key) throws -> UInt64 {
        guard let value = try primativeValue(forKey: key) as? UInt64 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode<T>(_ type: T.Type, forKey key: Key) throws -> T where T : Decodable {
        let t = DocumentSnapshotDecoder(documentSnapshot: documentSnapshot, codingPath: codingPath + [key], userInfo: self.userInfo)
        return try type.init(from: t)
    }

    func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: Key) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : CodingKey {
        return KeyedDecodingContainer(DocumentSnapshotKeyedDecodingContainerProtocol<NestedKey>(documentSnapshot: documentSnapshot, codingPath: codingPath + [key], userInfo: userInfo))
    }

    func nestedUnkeyedContainer(forKey key: Key) throws -> UnkeyedDecodingContainer {
        guard let value = try primativeValue(forKey: key) as? [Any] else {
            throw DecodingError.typeMismatch([Any].self, DecodingError.Context(codingPath: codingPath, debugDescription: "Unexpected type for key \(key)"))
        }
        return DocumentSnapshotUnkeyedDecodingContainer(documentSnapshot: documentSnapshot, codingPath: codingPath + [key], userInfo: userInfo, count: value.count, isAtEnd: value.isEmpty, currentIndex: 0)
    }

    func superDecoder() throws -> Decoder {
        throw FiremodelError.internalError
    }

    func superDecoder(forKey key: Key) throws -> Decoder {
        throw FiremodelError.internalError
    }
}


// MARK: - Standard Types

struct GeoPoint {
  let latitude: Float
  let longitude: Float
}

