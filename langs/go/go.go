package golang

import (
	"fmt"

	"github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
	"github.com/mickeyreiss/firemodel"
	"github.com/mickeyreiss/firemodel/version"
	"github.com/pkg/errors"
)

func init() {
	firemodel.RegisterModeler("go", &GoModeler{})
}

const (
	fileExtension = ".firemodel.go"
)

type GoModeler struct {
	pkg string
}

func (m *GoModeler) Model(schema *firemodel.Schema, sourceCoder firemodel.SourceCoder) error {
	m.pkg = schema.Options.Get("go")["package"]
	for _, model := range schema.Models {
		if err := m.writeModel(model, sourceCoder); err != nil {
			return err
		}
	}
	for _, enum := range schema.Enums {
		if err := m.writeEnum(enum, sourceCoder); err != nil {
			return err
		}
	}
	return nil
}

func (m *GoModeler) writeModel(model *firemodel.SchemaModel, sourceCoder firemodel.SourceCoder) error {
	f := jen.NewFile(m.packageName())
	f.HeaderComment(fmt.Sprintf("DO NOT EDIT - Code generated by firemodel %s.", version.Version))

	if model.Comment == "" {
		f.Commentf("TODO: Add comment to %s", model.Name)
	} else {
		f.Comment(model.Comment)
	}

	format, args, err := model.Options.GetFirestorePath()
	if err != nil {
		return errors.Wrap(err, "firemodel/go: invalid firestore path")
	}
	if format != "" {
		commentargs := make([]interface{}, len(args))
		for idx, arg := range args {
			commentargs[idx] = fmt.Sprintf("{%s}", arg)
		}
		f.Comment("")
		f.Commentf("Firestore document location: /%s", fmt.Sprintf(format, commentargs...))
	}

	f.Type().Id(model.Name).StructFunc(m.fields(model))

	if format, args, err := model.Options.GetFirestorePath(); format != "" {
		f.
			Commentf("%s returns the path to a particular %s in Firestore.", fmt.Sprint(model.Name, "Path"), model.Name)
		f.
			Func().
			Id(fmt.Sprint(model.Name, "Path")).
			ParamsFunc(func(g *jen.Group) {
				if err != nil {
					panic(err)
				}
				for _, arg := range args {
					g.Id(strcase.ToLowerCamel(arg)).String()
				}
			}).
			String().
			Block(jen.ReturnFunc(func(g *jen.Group) {
				if err != nil {
					panic(err)
				}
				g.
					Qual("fmt", "Sprintf").
					CallFunc(func(g *jen.Group) {
						g.Lit(format)
						for _, arg := range args {
							g.Id(strcase.ToLowerCamel(arg))
						}
					})
			}))
	}

	w, err := sourceCoder.NewFile(fmt.Sprint(strcase.ToSnake(model.Name), fileExtension))
	if err != nil {
		return errors.Wrap(err, "firemodel/go: open source code file")
	}
	defer w.Close()

	if err := f.Render(w); err != nil {
		return err
	}
	return nil
}

func (m *GoModeler) writeEnum(enum *firemodel.SchemaEnum, sourceCoder firemodel.SourceCoder) error {
	enumName := strcase.ToCamel(enum.Name)
	f := jen.NewFile(m.packageName())
	f.HeaderComment(fmt.Sprintf("DO NOT EDIT - Code generated by firemodel %s.", version.Version))

	if enum.Comment == "" {
		f.Commentf("TODO: Add comment to %s", enumName)
	} else {
		f.Comment(enum.Comment)
	}
	f.Type().Id(enumName).String()

	f.Const().DefsFunc(func(g *jen.Group) {
		for _, val := range enum.Values {
			if val.Comment != "" {
				g.Comment(val.Comment)
			}
			g.
				Id(fmt.Sprintf("%s_%s", enumName, strcase.ToScreamingSnake(val.Name))).
				Id(enumName).
				Op("=").
				Lit(strcase.ToScreamingSnake(val.Name))
		}
	})

	w, err := sourceCoder.NewFile(fmt.Sprint(strcase.ToSnake(enum.Name), fileExtension))
	if err != nil {
		return errors.Wrap(err, "firemodel/go: open source code file")
	}

	defer w.Close()

	if err := f.Render(w); err != nil {
		return err
	}
	return nil
}

func (m *GoModeler) packageName() string {
	if m.pkg == "" {
		return "firemodel"
	}
	return m.pkg
}

func (m *GoModeler) fields(model *firemodel.SchemaModel) func(g *jen.Group) {
	return func(g *jen.Group) {
		for _, field := range model.Fields {
			if field.Comment == "" {
				g.Commentf("TODO: Add comment to %s.%s.", model.Name, field.Name)
			} else {
				g.Comment(field.Comment)
			}
			g.
				Id(strcase.ToCamel(field.Name)).
				Do(m.goType(field.Type, field.Extras)).
				Tag(map[string]string{"firestore": strcase.ToLowerCamel(field.Name)})
		}

		if model.Options.GetAutoTimestamp() {
			g.Line()
			g.Comment("Creation timestamp.")
			g.
				Id("CreatedAt").
				Qual("time", "Time").
				Tag(map[string]string{"firestore": "createdAt,serverTimestamp"})

			g.Comment("Update timestamp.")
			g.
				Id("UpdatedAt").
				Qual("time", "Time").
				Tag(map[string]string{"firestore": "updatedAt,serverTimestamp"})
		}
	}
}

func (m *GoModeler) goType(firetype firemodel.SchemaFieldType, extras *firemodel.SchemaFieldExtras) func(s *jen.Statement) {
	switch firetype {
	case firemodel.Boolean:
		return func(s *jen.Statement) { s.Bool() }
	case firemodel.Integer:
		return func(s *jen.Statement) { s.Int64() }
	case firemodel.Double:
		return func(s *jen.Statement) { s.Float64() }
	case firemodel.Timestamp:
		return func(s *jen.Statement) { s.Qual("time", "Time") }
	case firemodel.String:
		if extras != nil && extras.EnumType != "" {
			return func(s *jen.Statement) { s.Id(extras.EnumType) }
		}
		if extras != nil && extras.URL {
			return func(s *jen.Statement) { s.Qual("github.com/mickeyreiss/firemodel/runtime", "URL") }
		}
		return func(s *jen.Statement) { s.String() }
	case firemodel.Bytes:
		return func(s *jen.Statement) { s.Index().Byte() }
	case firemodel.Reference:
		return func(s *jen.Statement) { s.Op("*").Qual("cloud.google.com/go/firestore", "DocumentRef") }
	case firemodel.GeoPoint:
		return func(s *jen.Statement) { s.Op("*").Qual("google.golang.org/genproto/googleapis/type/latlng", "LatLng") }
	case firemodel.Array:
		if extras != nil && extras.ArrayOfModel != "" {
			return func(s *jen.Statement) { s.Index().Id(extras.ArrayOfModel) }
		}
		if extras != nil && extras.ArrayOfEnum != "" {
			return func(s *jen.Statement) { s.Index().Id(extras.ArrayOfEnum) }
		}
		if extras != nil && extras.ArrayOfPrimitive != "" {
			return func(s *jen.Statement) { s.Index().Do(m.goType(extras.ArrayOfPrimitive, nil)) }
		}
		return func(s *jen.Statement) { s.Index().Interface() }
	case firemodel.Map:
		if extras != nil && extras.File {
			return func(s *jen.Statement) { s.Op("*").Qual("github.com/mickeyreiss/firemodel/runtime", "File") }
		}
		if extras != nil && extras.MapToModel != "" {
			return func(s *jen.Statement) { s.Op("*").Id(extras.MapToModel) }
		} else if extras != nil && extras.MapToEnum != "" {
			return func(s *jen.Statement) { s.Op("*").Id(extras.MapToEnum) }
		} else if extras != nil && extras.MapToPrimitive != "" {
			return func(s *jen.Statement) { s.Map(jen.String()).Do(m.goType(extras.MapToPrimitive, nil)) }
		}

		return func(s *jen.Statement) { s.Map(jen.String()).Interface() }
	default:
		err := errors.Errorf("firemodel/go: unknown type %s", firetype)
		panic(err)
	}
}
