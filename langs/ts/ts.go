package ts

import (
	"github.com/pkg/errors"
	"github.com/iancoleman/strcase"
	"fmt"
	"text/template"
	"github.com/mickeyreiss/firemodel"
)

func init() {
	firemodel.RegisterModeler("ts", &Modeler{})
}

type Modeler struct{}

func (m *Modeler) Model(schema *firemodel.Schema, sourceCoder firemodel.SourceCoder) error {
	f, err := sourceCoder.NewFile("firemodel.d.ts")
	if err != nil {
		return errors.Wrapf(err, "firemodel/ts: create typescript file")
	}
	defer f.Close()

	if err := tpl.Execute(f, schema); err != nil {
		return errors.Wrapf(err, "firemodel/ts: generating typescript")
	}
	return nil
}

var (
	tpl = template.Must(template.
		New("file").
		Funcs(map[string]interface{}{
			"toTypescriptType": toTypescriptType,
			"ToScreamingSnake": strcase.ToScreamingSnake,
			"ToLowerCamel":     strcase.ToLowerCamel,
			"ToCamel":          strcase.ToCamel,
			"getModelOption":   getModelOption,
			"getSchemaOption":  getSchemaOption,
			"interfaceName":    interfaceName,
		}).
		Parse(file),
	)
	_ = template.Must(tpl.New("model").Parse(model))
	_ = template.Must(tpl.New("enum").Parse(enum))
)

func interfaceName(sym string) string {
	return fmt.Sprintf("I%s", sym)
}

func toTypescriptType(firetype firemodel.SchemaFieldType, extras *firemodel.SchemaFieldExtras) string {
	switch firetype {
	case firemodel.Boolean:
		return "boolean"
	case firemodel.Integer, firemodel.Double:
		return "number"
	case firemodel.Timestamp:
		return "firebase.firestore.Timestamp"
	case firemodel.String:
		if extras != nil && extras.EnumType != "" {
			return extras.EnumType
		} else if extras != nil && extras.URL {
			return "URL"
		} else {
			return "string"
		}
	case firemodel.Bytes:
		return "firebase.firestore.Blob"
	case firemodel.Reference:
		if extras != nil && extras.ReferenceTo != "" {
			return fmt.Sprintf("DocumentReference<%s>", interfaceName(extras.ReferenceTo))
		} else {
			return "firebase.firestore.DocumentReference"
		}
	case firemodel.GeoPoint:
		return "firebase.firestore.GeoPoint"
	case firemodel.Array:
		if extras != nil && extras.ArrayOfModel != "" {
			return fmt.Sprintf("%s[]", interfaceName(extras.ArrayOfModel))
		} else if extras != nil && extras.ArrayOfEnum != "" {
			return fmt.Sprintf("%s[]", extras.ArrayOfEnum)
		} else if extras != nil && extras.ArrayOfPrimitive != "" {
			return fmt.Sprintf("%s[]", toTypescriptType(extras.ArrayOfPrimitive, nil))
		} else {
			return "any[]"
		}
	case firemodel.Map:
		if extras != nil && extras.File {
			return "IFile"
		} else if extras != nil && extras.MapToModel != "" {
			return interfaceName(extras.MapToModel)
		} else if extras != nil && extras.MapToEnum != "" {
			return extras.MapToEnum
		} else if extras != nil && extras.MapToPrimitive != "" {
			return fmt.Sprintf("{ [key: string]: %s; }", toTypescriptType(extras.MapToPrimitive, nil))
		} else {
			return `{ [key: string]: any; }`
		}
	default:
		err := errors.Errorf("firemodel/ts: unknown type %s", firetype)
		panic(err)
	}
}

func getSchemaOption(namespace string, key string, defaultValue string, options firemodel.SchemaOptions) string {
	ns, ok := options[namespace]
	if !ok {
		return defaultValue
	}
	opt, ok := ns[key]
	if !ok {
		return defaultValue
	}
	return opt
}

func getModelOption(namespace string, key string, required bool, options firemodel.SchemaModelOptions) string {
	ns, ok := options[namespace]
	if !ok {
		if required {
			err := errors.Errorf("option %s.%s is required but not set", namespace, key)
			panic(err)
		} else {
			return ""
		}
	}
	opt, ok := ns[key]
	if !ok {
		if required {
			err := errors.Errorf("option %s.%s is required but not set", namespace, key)
			panic(err)
		} else {
			return ""
		}
	}
	return opt
}

const (
	file = `// DO NOT EDIT - Code generated by firemodel.

import firebase from 'firebase';

export interface DocumentSnapshot<DataType = firebase.firestore.DocumentData>
  extends firebase.firestore.DocumentSnapshot {
  data(options?: firebase.firestore.SnapshotOptions): DataType | undefined;
}
export interface QueryDocumentSnapshot<
  DataType = firebase.firestore.DocumentData
> extends firebase.firestore.QueryDocumentSnapshot {
  data(options?: firebase.firestore.SnapshotOptions): DataType | undefined;
}
export interface QuerySnapshot<DataType = firebase.firestore.DocumentData>
  extends firebase.firestore.QuerySnapshot {
  readonly docs: QueryDocumentSnapshot<DataType>[];
}
export interface DocumentSnapshotExpanded<
  DataType = firebase.firestore.DocumentData
> {
  exists: firebase.firestore.DocumentSnapshot['exists'];
  ref: firebase.firestore.DocumentSnapshot['ref'];
  id: firebase.firestore.DocumentSnapshot['id'];
  metadata: firebase.firestore.DocumentSnapshot['metadata'];
  data: DataType;
}
export interface QuerySnapshotExpanded<
  DataType = firebase.firestore.DocumentData
> {
  metadata: {
    hasPendingWrites: firebase.firestore.QuerySnapshot['metadata']['hasPendingWrites'];
    fromCache: firebase.firestore.QuerySnapshot['metadata']['fromCache'];
  };
  size: firebase.firestore.QuerySnapshot['size'];
  empty: firebase.firestore.QuerySnapshot['empty'];
  docs: {
    [docId: string]: DocumentSnapshotExpanded<DataType>;
  };
}
export interface DocumentReference<DataType> extends firebase.firestore.DocumentReference {
  data(options?: firebase.firestore.SnapshotOptions): DataType | undefined;
}
export interface CollectionReference<
  DataType = firebase.firestore.DocumentData
> extends firebase.firestore.CollectionReference {
  get(options?: firebase.firestore.GetOptions): Promise<QuerySnapshot<DataType>>;
}
export interface Collection<DataType = firebase.firestore.DocumentData> {
  [id: string]: DocumentSnapshotExpanded<DataType>;
}

export namespace {{.Options | getSchemaOption "ts" "namespace" "firemodel"}} {
  type URL = string;

  export interface IFile {
    url: URL;
    mimeType: string;
    name: string;
  }


  {{- range .Enums -}}
  {{- template "enum" .}}
  {{- end}}
  {{- range .Models -}}
  {{- template "model" .}}
  {{- end}}
}
`
	model = `
  {{- if .Comment}}

  /** {{.Comment}} */
  {{- else}}

  /** TODO: Add documentation to {{.Name}}. */
  {{- end}}
  export interface {{.Name | interfaceName | ToCamel}} {
    {{- range .Collections}}
    {{- if .Comment}}
    /** {{.Comment}} */
    {{- else }}
    /** TODO: Add documentation to {{.Name}}. */
    {{- end}}
    {{.Name | ToLowerCamel}}: CollectionReference<{{.Type | interfaceName | ToCamel}}>;
    {{- end}}

    {{- range .Fields}}
    {{- if .Comment}}
    /** {{.Comment}} */
    {{- else }}
    /** TODO: Add documentation to {{.Name}}. */
    {{- end}}
    {{.Name | ToLowerCamel -}}?: {{toTypescriptType .Type .Extras}};
    {{- end}}
    {{- if .Options | getModelOption "firestore" "autotimestamp" false}}

    /** Record creation timestamp. */
    createdAt?: firebase.firestore.Timestamp;
    /** Record update timestamp. */
    updatedAt?: firebase.firestore.Timestamp;
    {{- end}}
  }`

	enum = `
  {{- if .Comment}}

  /** {{.Comment}} */
  {{- else}}

  /** TODO: Add documentation to {{.Name}}. */
  {{- end}}
  export enum {{.Name | ToCamel}} {
    {{- range .Values}}
    {{- if .Comment}}
    /** {{.Comment}} */
    {{- else}}
    /** TODO: Add documentation to {{.Name}}. */
    {{- end}}
    {{.Name}} = "{{.Name | ToScreamingSnake}}",
    {{- end}}
  }`
)
