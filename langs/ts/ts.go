package ts

import (
	"fmt"
	"text/template"

	"github.com/iancoleman/strcase"
	"github.com/pkg/errors"
	"github.com/visor-tax/firemodel"
	"github.com/visor-tax/firemodel/version"
)

func init() {
	firemodel.RegisterModeler("ts", &Modeler{})
}

type Modeler struct{}

func (m *Modeler) Model(schema *firemodel.Schema, sourceCoder firemodel.SourceCoder) error {
	f, err := sourceCoder.NewFile("firemodel.ts")
	if err != nil {
		return errors.Wrapf(err, "firemodel/ts: create typescript file")
	}
	defer f.Close()

	if err := tpl.Execute(f, schema); err != nil {
		return errors.Wrapf(err, "firemodel/ts: generating typescript")
	}
	return nil
}

var (
	tpl = template.Must(template.
		New("file").
		Funcs(map[string]interface{}{
			"firemodelVersion": func() string { return version.Version },
			"toTypescriptType": toTypescriptType,
			"ToScreamingSnake": strcase.ToScreamingSnake,
			"ToLowerCamel":     strcase.ToLowerCamel,
			"ToCamel":          strcase.ToCamel,
			"getModelOption":   getModelOption,
			"getSchemaOption":  getSchemaOption,
			"interfaceName":    interfaceName,
		}).
		Parse(file),
	)
	_ = template.Must(tpl.New("model").Parse(model))
	_ = template.Must(tpl.New("enum").Parse(enum))
	_ = template.Must(tpl.New("struct").Parse(structTpl))
)

func interfaceName(sym string) string {
	return fmt.Sprintf("I%s", sym)
}

func toTypescriptType(firetype firemodel.SchemaFieldType) string {
	switch firetype := firetype.(type) {
	case *firemodel.Boolean:
		return "boolean"
	case *firemodel.Integer, *firemodel.Double:
		return "number"
	case *firemodel.Timestamp:
		return "firestore.Timestamp"
	case *firemodel.String:
		return "string"
	case *firemodel.Enum:
		return firetype.T.Name
	case *firemodel.URL:
		return "URL"
	case *firemodel.Bytes:
		return "firestore.Blob"
	case *firemodel.Reference:
		if firetype.T != nil {
			return fmt.Sprintf("firestore.DocumentReference<%s>", interfaceName(firetype.T.Name))
		} else {
			return "firestore.DocumentReference"
		}
	case *firemodel.GeoPoint:
		return "firestore.GeoPoint"
	case *firemodel.Array:
		if firetype.T != nil {
			return fmt.Sprintf("%s[]", toTypescriptType(firetype.T))
		} else {
			return "any[]"
		}
	case *firemodel.Struct:
		return interfaceName(firetype.T.Name)
	case *firemodel.File:
		return "IFile"
	case *firemodel.Map:
		if firetype.T != nil {
			return fmt.Sprintf("{ [key: string]: %s; }", toTypescriptType(firetype.T))
		} else {
			return `{ [key: string]: any; }`
		}
	default:
		err := errors.Errorf("firemodel/ts: unknown type %s", firetype)
		panic(err)
	}
}

func getSchemaOption(namespace string, key string, defaultValue string, options firemodel.SchemaOptions) string {
	ns, ok := options[namespace]
	if !ok {
		return defaultValue
	}
	opt, ok := ns[key]
	if !ok {
		return defaultValue
	}
	return opt
}

func getModelOption(namespace string, key string, required bool, options firemodel.SchemaModelOptions) string {
	ns, ok := options[namespace]
	if !ok {
		if required {
			err := errors.Errorf("option %s.%s is required but not set", namespace, key)
			panic(err)
		} else {
			return ""
		}
	}
	opt, ok := ns[key]
	if !ok {
		if required {
			err := errors.Errorf("option %s.%s is required but not set", namespace, key)
			panic(err)
		} else {
			return ""
		}
	}
	return opt
}

const (
	file = `// DO NOT EDIT - Code generated by firemodel {{firemodelVersion}}.
import { firestore } from 'firebase';

// tslint:disable-next-line:no-namespace
export namespace {{.Options | getSchemaOption "ts" "namespace" "firemodel"}} {
  type URL = string;

  export interface IFile {
    url: URL;
    mimeType: string;
    name: string;
  }

  {{- range .Enums -}}
  {{- template "enum" .}}
  {{- end}}
  {{- range .Structs -}}
  {{- template "struct" .}}
  {{- end}}
  {{- range .Models -}}
  {{- template "model" .}}
  {{- end}}
}
`
	model = `
  {{- if .Comment}}

  /** {{.Comment}} */
  {{- else}}

  /** TODO: Add documentation to {{.Name}} in firemodel schema. */
  {{- end}}
  export interface {{.Name | interfaceName | ToCamel}} {
    {{- range .Collections}}
    {{- if .Comment}}
    /** {{.Comment}} */
    {{- else }}
    /** TODO: Add documentation to {{.Name}} in firemodel schema. */
    {{- end}}
    {{.Name | ToLowerCamel}}: firestore.CollectionReference<{{.Type.Name | interfaceName | ToCamel}}>;
    {{- end}}

    {{- range .Fields}}
    {{- if .Comment}}
    /** {{.Comment}} */
    {{- else }}
    /** TODO: Add documentation to {{.Name}} in firemodel schema. */
    {{- end}}
    {{.Name | ToLowerCamel -}}?: {{toTypescriptType .Type}};
    {{- end}}
    {{- if .Options | getModelOption "firestore" "autotimestamp" false}}

    /** Record creation timestamp. */
    createdAt?: firestore.Timestamp;
    /** Record update timestamp. */
    updatedAt?: firestore.Timestamp;
    {{- end}}
  }`

	structTpl = `
  {{- if .Comment}}

  /** {{.Comment}} */
  {{- else}}

  /** TODO: Add documentation to {{.Name}} in firemodel schema. */
  {{- end}}
  export interface {{.Name | interfaceName | ToCamel}} {
    {{- range .Fields}}
    {{- if .Comment}}
    /** {{.Comment}} */
    {{- else }}
    /** TODO: Add documentation to {{.Name}} in firemodel schema. */
    {{- end}}
    {{.Name | ToLowerCamel -}}?: {{toTypescriptType .Type}};
    {{- end}}
  }`

	enum = `
  {{- if .Comment}}

  /** {{.Comment}} */
  {{- else}}

  /** TODO: Add documentation to {{.Name}} in firemodel schema. */
  {{- end}}
  export enum {{.Name | ToCamel}} {
    {{- range .Values}}
    {{- if .Comment}}
    /** {{.Comment}} */
    {{- else}}
    /** TODO: Add documentation to {{.Name}} in firemodel schema. */
    {{- end}}
    {{.Name}} = '{{.Name | ToScreamingSnake}}',
    {{- end}}
  }`
)
