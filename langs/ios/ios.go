package ios

import (
	"fmt"
	"text/template"

	"github.com/iancoleman/strcase"
	"github.com/mickeyreiss/firemodel"
	"github.com/pkg/errors"
	"strings"
)

func init() {
	firemodel.RegisterModeler("ios", &Modeler{})
}

type Modeler struct{}

func (m *Modeler) Model(schema *firemodel.Schema, sourceCoder firemodel.SourceCoder) error {
	f, err := sourceCoder.NewFile("firemodel.swift")
	if err != nil {
		return errors.Wrapf(err, "firemodel/ios: create swift file")
	}
	defer f.Close()

	if err := tpl.Execute(f, schema); err != nil {
		return errors.Wrapf(err, "firemodel/ios: generating swift")
	}
	return nil
}

var (
	tpl = template.Must(template.
		New("file").
		Funcs(map[string]interface{}{
			"toSwiftType":                    toSwiftType,
			"toScreamingSnake":               strcase.ToScreamingSnake,
			"toCamel":                        strcase.ToCamel,
			"toLowerCamel":                   strcase.ToLowerCamel,
			"filterFieldsEnumsOnly":          filterFieldsEnumsOnly,
			"asStaticConfigForFirestorePath": asStaticConfigForFirestorePath,
		}).
		Parse(file),
	)
	_ = template.Must(tpl.New("model").Parse(model))
	_ = template.Must(tpl.New("enum").Parse(enum))
)

func filterFieldsEnumsOnly(in []*firemodel.SchemaField) []*firemodel.SchemaField {
	var out []*firemodel.SchemaField
	for _, i := range in {
		if i.Extras == nil || i.Extras.EnumType == "" {
			continue
		}
		out = append(out, i)
	}
	return out
}

func toSwiftType(extras *firemodel.SchemaFieldExtras, root bool, firetype firemodel.SchemaFieldType) string {
	switch firetype {
	case firemodel.Boolean:
		return "Bool = false"
	case firemodel.Integer:
		return "Int = 0"
	case firemodel.Double:
		return "Float = 0.0"
	case firemodel.Timestamp:
		return "Date = Date()"
	case firemodel.String:
		if extras != nil && extras.EnumType != "" {
			if root {
				return fmt.Sprintf("%s?", strcase.ToCamel(extras.EnumType))
			} else {
				return fmt.Sprintf("%s", strcase.ToCamel(extras.EnumType))
			}
		} else if extras != nil && extras.URL {
			if root {
				return "URL?"
			} else {
				return "URL"
			}
		} else {
			if root {
				return "String?"
			} else {
				return "String"
			}
		}
	case firemodel.Bytes:
		if root {
			return "Data?"
		} else {
			return "Data"
		}
	case firemodel.Reference:
		if extras != nil && extras.ReferenceTo != "" {
			return fmt.Sprintf("Pring.Reference<%s> = .init()", extras.ReferenceTo)
		} else {
			return "Pring.AnyReference"
		}
	case firemodel.GeoPoint:
		if root {
			return "Pring.GeoPoint?"
		} else {
			return "Pring.GeoPoint"
		}
	case firemodel.Array:
		if extras != nil && extras.ArrayOfModel != "" {
			return fmt.Sprintf("[%s] = []", extras.ArrayOfModel)
		} else if extras != nil && extras.ArrayOfEnum != "" {
			return fmt.Sprintf("[%s] = []", extras.ArrayOfEnum)
		} else if extras != nil && extras.ArrayOfPrimitive != "" {
			return fmt.Sprintf("[%s] = []", toSwiftType(nil, false, extras.ArrayOfPrimitive))
		} else {
			return "[Any]"
		}
	case firemodel.Map:
		if extras != nil && extras.File {
			if root {
				return "Pring.File?"
			} else {
				return "Pring.File"
			}
		} else if extras != nil && extras.MapToModel != "" {
			if root {
				return fmt.Sprintf("%s?", extras.MapToModel)
			} else {
				return fmt.Sprintf("%s", extras.MapToModel)
			}
		} else if extras != nil && extras.MapToEnum != "" {
			if root {
				return fmt.Sprintf("%s?", extras.MapToEnum)
			} else {
				return fmt.Sprintf("%s", extras.MapToEnum)
			}
		} else if extras != nil && extras.MapToPrimitive != "" {
			return fmt.Sprintf("[String: %s] = [:]", toSwiftType(nil, false, extras.MapToPrimitive))
		} else {
			return "[AnyHashable: Any] = [:]"
		}
	default:
		err := errors.Errorf("firemodel/ios: unknown type %s", firetype)
		panic(err)
	}
}

func asStaticConfigForFirestorePath(options firemodel.SchemaModelOptions) string {
	format, args, err := options.GetFirestorePath()
	if err != nil {
		panic(err)
	}
	var out strings.Builder

	for _, arg := range args {
		fmt.Fprintf(&out, "static var %s: String = \"\"\n", strcase.ToLowerCamel(arg))
	}

	argsWrappedInInterpolationParens := make([]interface{}, len(args))
	for idx, arg := range args {
		argsWrappedInInterpolationParens[idx] = fmt.Sprintf(`\(%s)`, strcase.ToLowerCamel(arg))
	}
	path := fmt.Sprintf(format, argsWrappedInInterpolationParens...)

	fmt.Fprintf(&out, "    override class var path: String { return \"%s\" }\n", path)

	return out.String()
}

const (
	file = `// DO NOT EDIT - Code generated by firemodel.

import Foundation
import Pring
{{range .Enums -}}
{{template "enum" .}}
{{- end}}
{{- range .Models -}}
{{- template "model" .}}
{{- end -}}`

	model = `
{{- if .Comment}}
// {{.Comment}}
{{- else}}
// TODO: Add documentation to {{.Name | toCamel}}.
{{- end}}
@objcMembers class {{.Name | toCamel}}: Pring.Object {
    {{.Options | asStaticConfigForFirestorePath -}}
    {{- range .Fields}}
    {{- if .Comment}}
    // {{.Comment}}
    {{- else }}
    // TODO: Add documentation to {{.Name | toLowerCamel}}.
    {{- end}}
    dynamic var {{.Name | toLowerCamel -}}: {{.Type | toSwiftType .Extras true}}
    {{- end}}

    {{- range .Collections}}
    {{- if .Comment}}
    // {{.Comment}}
    {{- else }}
    // TODO: Add documentation to {{.Name}}.
    {{- end}}
    dynamic var {{.Name | toLowerCamel}}: Pring.NestedCollection<{{.Type}}> = []
    {{- end}}

    {{ if .Fields | filterFieldsEnumsOnly -}}
    override func encode(_ key: String, value: Any?) -> Any? {
        switch key {
        {{range .Fields | filterFieldsEnumsOnly -}}
        case "{{.Name | toLowerCamel}}":
            return self.{{.Name | toLowerCamel}}?.firestoreValue
            {{- end}}
        default:
            break
        }
        return nil
    }

    override func decode(_ key: String, value: Any?) -> Bool {
        switch key {
        {{range .Fields | filterFieldsEnumsOnly -}}
        case "{{.Name | toLowerCamel}}":
            self.{{.Name | toLowerCamel}} = {{.Name | toCamel }}(firestoreValue: value)
            {{- end}}
        default:
            break
        }
        return false
    }
    {{- end}}
}
`
	enum = `
{{- if .Comment}}
// {{.Comment}}
{{- else}}
// TODO: Add documentation to {{.Name}}.
{{- end}}
@objc enum {{.Name | toCamel }}: Int {
    {{- range .Values}}
    {{- if .Comment}}
    // {{.Comment}}
    {{- else}}
    // TODO: Add documentation to {{.Name}}.
    {{- end}}
    case {{.Name}}
    {{- end}}
}

extension {{.Name}}: CustomDebugStringConvertible {
    init?(firestoreValue value: Any?) {
        guard let value = value as? String else {
            return nil
        }
        switch value {
        {{- range $v := .Values}}
        case "{{$v.Name | toScreamingSnake}}":
            self = .{{$v.Name | toLowerCamel }}
        {{- end}}
        default:
            return nil
        }
    }

    var firestoreValue: String? {
        switch self {
        {{- range .Values}}
        case .{{.Name | toLowerCamel}}:
            return "{{.Name | toScreamingSnake}}"
        {{- end}}
        default:
            return nil
        }
    }

    var debugDescription: String { return firestoreValue ?? "<INVALID>" }
}
`
)
