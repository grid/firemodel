// DO NOT EDIT - Code generated by firemodel (dev).

import Foundation
import FirebaseFirestore

// MARK: - Models

// [new] It is now assumed that all fields of all types (other than enums associated values) are optional. In order to facilitate queries on missing fields, missing fields are saved in firestore as explicit null values.
struct User {
    let username: String?
    let displayName: String?
    let avatar: Avatar?
}

struct Gram {
    let sharedWith: Audience?
    let photoUrl: URL?
    let description: String?
    let tags: [String]
}

struct Message {
    let content: MessageContent?
    let from: FriendRef?
}

struct Attachment {
    let title: String?
    let content: AttachmentContent?
}

struct Friend {
    let username: String?
    let displayName: String?
    let avatar: Avatar?
    let friendsSinice: Date?
}


// MARK: - Structs

// firestore client libraries.
struct Avatar {
    let url: URL?
    let color: String?
}

struct SendMessageRequest {
    let to: FriendRef?
    let content: MessageContent?
}

struct ImojiAttachment {
    let coolPic: Data?
}

struct GramAttachment {
    let ref: String?
}

struct UploadAttachment {
    let title: String?
    let src: URL?
}

struct Upload {
    let url: URL?
    let mimeType: String?
}

struct TextMessageContent {
    let message: String?
}

struct PhotoMessageContent {
    let caption: String?
    let url: URL?
}


// MARK: - Enums

// [unchanged] Enums provide type safety around string enumerations. Enums are stored in firestore as capitalized strings.
enum Audience {
    case global
    case friends
}

// for enum values other than the active one are not written to firestore.
enum AttachmentContent {
    // e.g. for an Attachment, written as `content = "PLACEHOLDER"`
    case placeholder
    // e.g. for an Attachment, written as `content = "IMOJI", content.imoji = #BYTES#`
    case imoji(ImojiAttachment)
    // e.g. for an Attachment, written as `content = "IMOJI", content.imoji = #BYTES#`
    case gram(GramAttachment)
    // e.g. for an Attachment, written as `content = "UPLOAD", content.upload.token = "oijasdf", content.upload.etc = the_rest`
    case upload(UploadAttachment)
}

enum MessageContent {
    case text(TextMessageContent)
    case photo(PhotoMessageContent)
}


// MARK: - References

struct UserRef: FiremodelCollectionSubscriber {
    fileprivate let ref: DocumentReference
    fileprivate let client: FiremodelClient

    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<User>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [User]()
                var diff = (additions: [FiremodelChange<User>](), modifications: [FiremodelChange<User>](), removals: [FiremodelChange<User>]())
                for change in snap.documentChanges {
                    let model: User
                    do {
                        model = try self.client.decode(User.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}

struct GramRef: FiremodelCollectionSubscriber {
    fileprivate let ref: DocumentReference
    fileprivate let client: FiremodelClient

    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<Gram>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [Gram]()
                var diff = (additions: [FiremodelChange<Gram>](), modifications: [FiremodelChange<Gram>](), removals: [FiremodelChange<Gram>]())
                for change in snap.documentChanges {
                    let model: Gram
                    do {
                        model = try self.client.decode(Gram.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}

struct MessageRef: FiremodelCollectionSubscriber {
    fileprivate let ref: DocumentReference
    fileprivate let client: FiremodelClient

    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<Message>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [Message]()
                var diff = (additions: [FiremodelChange<Message>](), modifications: [FiremodelChange<Message>](), removals: [FiremodelChange<Message>]())
                for change in snap.documentChanges {
                    let model: Message
                    do {
                        model = try self.client.decode(Message.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}

struct AttachmentRef: FiremodelCollectionSubscriber {
    fileprivate let ref: DocumentReference
    fileprivate let client: FiremodelClient

    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<Attachment>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [Attachment]()
                var diff = (additions: [FiremodelChange<Attachment>](), modifications: [FiremodelChange<Attachment>](), removals: [FiremodelChange<Attachment>]())
                for change in snap.documentChanges {
                    let model: Attachment
                    do {
                        model = try self.client.decode(Attachment.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}

struct FriendRef: FiremodelCollectionSubscriber {
    fileprivate let ref: DocumentReference
    fileprivate let client: FiremodelClient

    func subscribe(withQuery applyQuery: ((Query) -> Query)? = nil,
                   receiver publish: @escaping (FiremodelCollectionEvent<Friend>) -> Void) -> FiremodelUnsubscriber {

        let registration = (applyQuery?(ref) ?? ref)
            .addSnapshotListener { (snap: QuerySnapshot?, error: Error?) in
                if let error = error {
                    publish(.error(error))
                    return
                }
                guard let snap = snap else {
                    assertionFailure("Error was nil but Snapshot was also nil. This is unexpected behavior from addSnapshotListener!")
                    publish(.error(FiremodelError.internalError))
                    return
                }


                var documents = [Friend]()
                var diff = (additions: [FiremodelChange<Friend>](), modifications: [FiremodelChange<Friend>](), removals: [FiremodelChange<Friend>]())
                for change in snap.documentChanges {
                    let model: Friend
                    do {
                        model = try self.client.decode(Friend.self, from: change.document)
                    } catch {
                        publish(.error(error))
                        return
                    }

                    documents.append(model)

                    let firemodelChange = FiremodelChange(document: model, oldIndex: change.oldIndex, newIndex: change.newIndex)

                    switch change.type {
                    case DocumentChangeType.added:
                        diff.additions.append(firemodelChange)
                    case DocumentChangeType.modified:
                        diff.modifications.append(firemodelChange)
                    case DocumentChangeType.removed:
                        diff.removals.append(firemodelChange)
                    default:
                        assertionFailure("unexpected firestore DocumentChangeType \(change.type)")
                    }

                }

                publish(.snapshot(documents, diff: diff, metadata: snap.metadata as SnapshotMetadata))
        }

        return FiremodelUnsubscriber(listenerRegistration: registration)
    }
}


// MARK: - Coding

extension User: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.username = try container.decodeIfPresent(String.self, forKey: .username)
        self.displayName = try container.decodeIfPresent(String.self, forKey: .displayName)
        self.avatar = try container.decodeIfPresent(Avatar.self, forKey: .avatar)
    }

    // Coding keys for User.
    enum CodingKeys: String, CodingKey {
        case username = "username"
        case displayName = "display_name"
        case avatar = "avatar"
    }
}

extension Gram: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let sharedWithType = try container.decodeIfPresent(String.self, forKey: .sharedWith)
        let sharedWith = try container.nestedContainer(keyedBy: AudienceType.self, forKey: .sharedWith)
        self.photoUrl = try container.decodeIfPresent(URL.self, forKey: .photoUrl)
        self.description = try container.decodeIfPresent(String.self, forKey: .description)
        self.tags =  try container.decodeIfPresent([String])

    }

    // Coding keys for Gram.
    enum CodingKeys: String, CodingKey {
        case sharedWith = "shared_with"
        case photoUrl = "photo_url"
        case description = "description"
        case tags = "tags"
    }
    // Coding keys for the Audience enum’s associated value.
    enum AudienceType: String, CodingKey {
        case global = "global"
        case friends = "friends"
    }
}

extension Message: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let contentType = try container.decodeIfPresent(String.self, forKey: .content)
        let content = try container.nestedContainer(keyedBy: MessageContentType.self, forKey: .content)
        switch contentType {
        case MessageContent.text.rawValue:
            self.text = try container.decodeIfPresent(TextMessageContent.self, forKey: .text)
        case MessageContent.photo.rawValue:
            self.photo = try container.decodeIfPresent(PhotoMessageContent.self, forKey: .photo)
        default:
            break
        }
        self.from = try container.decodeIfPresent(FriendRef.self, forKey: .from)
    }

    // Coding keys for Message.
    enum CodingKeys: String, CodingKey {
        case content = "content"
        case from = "from"
    }
    // Coding keys for the MessageContent enum’s associated value.
    enum MessageContentType: String, CodingKey {
        case text = "text"
        case photo = "photo"
    }
}

extension Attachment: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.title = try container.decodeIfPresent(String.self, forKey: .title)
        let contentType = try container.decodeIfPresent(String.self, forKey: .content)
        let content = try container.nestedContainer(keyedBy: AttachmentContentType.self, forKey: .content)
        switch contentType {
        case AttachmentContent.imoji.rawValue:
            self.imoji = try container.decodeIfPresent(ImojiAttachment.self, forKey: .imoji)
        case AttachmentContent.gram.rawValue:
            self.gram = try container.decodeIfPresent(GramAttachment.self, forKey: .gram)
        case AttachmentContent.upload.rawValue:
            self.upload = try container.decodeIfPresent(UploadAttachment.self, forKey: .upload)
        default:
            break
        }
    }

    // Coding keys for Attachment.
    enum CodingKeys: String, CodingKey {
        case title = "title"
        case content = "content"
    }
    // Coding keys for the AttachmentContent enum’s associated value.
    enum AttachmentContentType: String, CodingKey {
        case placeholder = "placeholder"
        case imoji = "imoji"
        case gram = "gram"
        case upload = "upload"
    }
}

extension Friend: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.username = try container.decodeIfPresent(String.self, forKey: .username)
        self.displayName = try container.decodeIfPresent(String.self, forKey: .displayName)
        self.avatar = try container.decodeIfPresent(Avatar.self, forKey: .avatar)
        self.friendsSinice = try container.decodeIfPresent(Date.self, forKey: .friendsSinice)
    }

    // Coding keys for Friend.
    enum CodingKeys: String, CodingKey {
        case username = "username"
        case displayName = "display_name"
        case avatar = "avatar"
        case friendsSinice = "friends_sinice"
    }
}


extension Avatar: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.url = try container.decodeIfPresent(URL.self, forKey: .url)
        self.color = try container.decodeIfPresent(String.self, forKey: .color)
    }

    // Coding keys for Avatar.
    enum CodingKeys: String, CodingKey {
        case url = "url"
        case color = "color"
    }
}

extension SendMessageRequest: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.to = try container.decodeIfPresent(FriendRef.self, forKey: .to)
        let contentType = try container.decodeIfPresent(String.self, forKey: .content)
        let content = try container.nestedContainer(keyedBy: MessageContentType.self, forKey: .content)
        switch contentType {
        case MessageContent.text.rawValue:
            self.text = try container.decodeIfPresent(TextMessageContent.self, forKey: .text)
        case MessageContent.photo.rawValue:
            self.photo = try container.decodeIfPresent(PhotoMessageContent.self, forKey: .photo)
        default:
            break
        }
    }

    // Coding keys for SendMessageRequest.
    enum CodingKeys: String, CodingKey {
        case to = "to"
        case content = "content"
    }
    // Coding keys for the MessageContent enum’s associated value.
    enum MessageContentType: String, CodingKey {
        case text = "text"
        case photo = "photo"
    }
}

extension ImojiAttachment: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.coolPic = try container.decodeIfPresent(Data.self, forKey: .coolPic)
    }

    // Coding keys for ImojiAttachment.
    enum CodingKeys: String, CodingKey {
        case coolPic = "cool_pic"
    }
}

extension GramAttachment: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.ref = try container.decodeIfPresent(String.self, forKey: .ref)
    }

    // Coding keys for GramAttachment.
    enum CodingKeys: String, CodingKey {
        case ref = "ref"
    }
}

extension UploadAttachment: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.title = try container.decodeIfPresent(String.self, forKey: .title)
        self.src = try container.decodeIfPresent(URL.self, forKey: .src)
    }

    // Coding keys for UploadAttachment.
    enum CodingKeys: String, CodingKey {
        case title = "title"
        case src = "src"
    }
}

extension Upload: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.url = try container.decodeIfPresent(URL.self, forKey: .url)
        self.mimeType = try container.decodeIfPresent(String.self, forKey: .mimeType)
    }

    // Coding keys for Upload.
    enum CodingKeys: String, CodingKey {
        case url = "url"
        case mimeType = "mime_type"
    }
}

extension TextMessageContent: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.message = try container.decodeIfPresent(String.self, forKey: .message)
    }

    // Coding keys for TextMessageContent.
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }
}

extension PhotoMessageContent: Decodable {
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.caption = try container.decodeIfPresent(String.self, forKey: .caption)
        self.url = try container.decodeIfPresent(URL.self, forKey: .url)
    }

    // Coding keys for PhotoMessageContent.
    enum CodingKeys: String, CodingKey {
        case caption = "caption"
        case url = "url"
    }
}




typealias Source = FirebaseFirestore.FirestoreSource

// MARK: - Protocols

protocol FiremodelDocumentSubscriber {
    associatedtype DocumentType
    func subscribe(receiver publish: @escaping (FiremodelDocumentEvent<DocumentType>) -> Void) -> FiremodelUnsubscriber
}

enum FiremodelDocumentEvent<T> {
    case snapshot(_: T, metadata: SnapshotMetadata)
    case error(Error)
}

protocol FiremodelCollectionSubscriber {
    associatedtype DocumentType
    func subscribe(withQuery applyQuery: ((Query) -> Query)?,
                   receiver publish: @escaping (FiremodelCollectionEvent<DocumentType>) -> Void) -> FiremodelUnsubscriber
}

class FiremodelUnsubscriber {
    private var listenerRegistration: ListenerRegistration?
    private var unsubscribeOnDeinit: Bool = true

    fileprivate init(listenerRegistration: ListenerRegistration) {
        self.listenerRegistration = listenerRegistration
    }

    // Shared prevents the automatic unsubscribe behavior for rare cases when the listener registration is never retained.
    func shared() {
        self.unsubscribeOnDeinit = false
    }

    deinit {
        if unsubscribeOnDeinit {
            unsubscribe()
        }
    }

    func unsubscribe() {
        listenerRegistration?.remove()
        listenerRegistration = nil
    }
}

enum FiremodelCollectionEvent<T> {
    case snapshot(_: [T], diff: (additions: [FiremodelChange<T>], modifications: [FiremodelChange<T>], removals: [FiremodelChange<T>]), metadata: SnapshotMetadata)
    case error(Error)
}

struct FiremodelChange<T> {
    let document: T
    let oldIndex: UInt
    let newIndex: UInt
}

// MARK: - Client

class FiremodelClient {
    private let firestore: FirebaseFirestore.Firestore

    static func dev() -> FiremodelClient {
        let firestore = FirebaseFirestore.Firestore.firestore()
        return FiremodelClient(firestore: firestore)
    }

    init(firestore: FirebaseFirestore.Firestore) {
        self.firestore = firestore
    }

    // MARK: - Root Collections

    func users() -> UserCollectionRef {
        return UserCollectionRef(ref: firestore.collection("users"), client: self)
    }

    func user(id: String) -> UserRef {
        return users().user(id: id)
    }

    // MARK: - Decoding

    func decode<T>(_ type: T.Type, from snapshot: FirebaseFirestore.DocumentSnapshot) throws -> T where T: Decodable {
        let decoder = DocumentSnapshotDecoder(documentSnapshot: snapshot,
                                              codingPath: [],
                                              userInfo: [firestoreClientDecodingKey: self])

        return try type.init(from: decoder)
    }

    func rawDocumentReference(_ path: String) -> DocumentReference {
        return self.firestore.document(path)
    }
}

fileprivate let firestoreClientDecodingKey = CodingUserInfoKey(rawValue: "firestore")!


// MARK: - Decoder

struct DocumentSnapshotKey: CodingKey {
    let stringValue: String

    let intValue: Int? = nil

    init?(stringValue: String) {
        self.stringValue = stringValue
    }

    init?(intValue: Int) {
        return nil
    }
}

enum DocumentSnapshotDecodingError: Error {
    case firestoreClientMissing
}

struct DocumentSnapshotDecoder: Decoder {
    let documentSnapshot: DocumentSnapshot
    let codingPath: [CodingKey]
    let userInfo: [CodingUserInfoKey : Any]

    func container<Key>(keyedBy type: Key.Type) throws -> KeyedDecodingContainer<Key> where Key : CodingKey {
        return KeyedDecodingContainer(DocumentSnapshotKeyedDecodingContainerProtocol<Key>(documentSnapshot: documentSnapshot, codingPath: codingPath, userInfo: userInfo))
    }
    func singleValueContainer() throws -> SingleValueDecodingContainer {
        return DocumentSnapshotSingleValueDecodingContainer(documentSnapshot: documentSnapshot, codingPath: codingPath, userInfo: userInfo)
    }
    func unkeyedContainer() throws -> UnkeyedDecodingContainer {
        throw FiremodelError.typeError
    }
}

struct DocumentSnapshotUnkeyedDecodingContainer: UnkeyedDecodingContainer {
    let documentSnapshot: DocumentSnapshot

    let codingPath: [CodingKey]

    let userInfo: [CodingUserInfoKey: Any]

    var count: Int?

    var isAtEnd: Bool

    var currentIndex: Int

    mutating func decodeNil() throws -> Bool {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Bool.Type) throws -> Bool {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: String.Type) throws -> String {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Double.Type) throws -> Double {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Float.Type) throws -> Float {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int.Type) throws -> Int {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int8.Type) throws -> Int8 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int16.Type) throws -> Int16 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int32.Type) throws -> Int32 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: Int64.Type) throws -> Int64 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt.Type) throws -> UInt {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt8.Type) throws -> UInt8 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt16.Type) throws -> UInt16 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt32.Type) throws -> UInt32 {
        throw FiremodelError.internalError
    }

    mutating func decode(_ type: UInt64.Type) throws -> UInt64 {
        throw FiremodelError.internalError
    }

    mutating func decode<T>(_ type: T.Type) throws -> T where T : Decodable {
        throw FiremodelError.internalError
    }

    mutating func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : CodingKey {
        throw FiremodelError.internalError
    }

    mutating func nestedUnkeyedContainer() throws -> UnkeyedDecodingContainer {
        throw FiremodelError.internalError
    }

    mutating func superDecoder() throws -> Decoder {
        throw FiremodelError.internalError
    }
}

struct DocumentSnapshotSingleValueDecodingContainer: SingleValueDecodingContainer {
    let documentSnapshot: DocumentSnapshot
    let codingPath: [CodingKey]
    let userInfo: [CodingUserInfoKey: Any]

    func decodeNil() -> Bool {
        return false
    }

    func decode(_ type: Bool.Type) throws -> Bool {
        throw FiremodelError.internalError
    }

    func decode(_ type: String.Type) throws -> String {
        throw FiremodelError.internalError
    }

    func decode(_ type: Double.Type) throws -> Double {
        throw FiremodelError.internalError
    }

    func decode(_ type: Float.Type) throws -> Float {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int.Type) throws -> Int {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int8.Type) throws -> Int8 {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int16.Type) throws -> Int16 {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int32.Type) throws -> Int32 {
        throw FiremodelError.internalError
    }

    func decode(_ type: Int64.Type) throws -> Int64 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt.Type) throws -> UInt {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt8.Type) throws -> UInt8 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt16.Type) throws -> UInt16 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt32.Type) throws -> UInt32 {
        throw FiremodelError.internalError
    }

    func decode(_ type: UInt64.Type) throws -> UInt64 {
        throw FiremodelError.internalError
    }

    func decode<T>(_ type: T.Type) throws -> T where T : Decodable {
        throw FiremodelError.internalError
    }
}

struct DocumentSnapshotKeyedDecodingContainerProtocol<Key>: KeyedDecodingContainerProtocol where Key : CodingKey {
    let documentSnapshot: DocumentSnapshot
    let codingPath: [CodingKey]
    let userInfo: [CodingUserInfoKey: Any]

    var allKeys: [Key] {
        return Array(self.documentSnapshot.data()?.keys.compactMap { Key(stringValue: $0) } ?? [])
    }

    func contains(_ key: Key) -> Bool {
        return self.documentSnapshot.data()?.keys.contains(key.stringValue) ?? false
    }

    func decodeNil(forKey key: Key) throws -> Bool {
        return documentSnapshot.get(key.stringValue) == nil
    }

    private func primativeValue(forKey key: Key) throws -> Any {
        let fp = FieldPath(codingPath.map { $0.stringValue } + [key.stringValue])
        guard case let .some(value) = documentSnapshot.get(fp) else {
            throw DecodingError.keyNotFound(key, DecodingError.Context(codingPath: codingPath, debugDescription: "key missing"))
        }
        return value
    }

    func decode(_ type: Bool.Type, forKey key: Key) throws -> Bool {
        guard let value = try primativeValue(forKey: key) as? Bool else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: String.Type, forKey key: Key) throws -> String {
        guard let value = try primativeValue(forKey: key) as? String else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Double.Type, forKey key: Key) throws -> Double {
        guard let value = try primativeValue(forKey: key) as? Double else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Float.Type, forKey key: Key) throws -> Float {
        guard let value = try primativeValue(forKey: key) as? Float else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int.Type, forKey key: Key) throws -> Int {
        guard let value = try primativeValue(forKey: key) as? Int else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int8.Type, forKey key: Key) throws -> Int8 {
        guard let value = try primativeValue(forKey: key) as? Int8 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int16.Type, forKey key: Key) throws -> Int16 {
        guard let value = try primativeValue(forKey: key) as? Int16 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int32.Type, forKey key: Key) throws -> Int32 {
        guard let value = try primativeValue(forKey: key) as? Int32 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: Int64.Type, forKey key: Key) throws -> Int64 {
        guard let value = try primativeValue(forKey: key) as? Int64 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt.Type, forKey key: Key) throws -> UInt {
        guard let value = try primativeValue(forKey: key) as? UInt else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt8.Type, forKey key: Key) throws -> UInt8 {
        guard let value = try primativeValue(forKey: key) as? UInt8 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt16.Type, forKey key: Key) throws -> UInt16 {
        guard let value = try primativeValue(forKey: key) as? UInt16 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt32.Type, forKey key: Key) throws -> UInt32 {
        guard let value = try primativeValue(forKey: key) as? UInt32 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode(_ type: UInt64.Type, forKey key: Key) throws -> UInt64 {
        guard let value = try primativeValue(forKey: key) as? UInt64 else {
            throw DecodingError.typeMismatch(type, DecodingError.Context(codingPath: codingPath, debugDescription: "invalid type"))
        }
        return value
    }

    func decode<T>(_ type: T.Type, forKey key: Key) throws -> T where T : Decodable {
        let t = DocumentSnapshotDecoder(documentSnapshot: documentSnapshot, codingPath: codingPath + [key], userInfo: self.userInfo)
        return try type.init(from: t)
    }

    func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type, forKey key: Key) throws -> KeyedDecodingContainer<NestedKey> where NestedKey : CodingKey {
        return KeyedDecodingContainer(DocumentSnapshotKeyedDecodingContainerProtocol<NestedKey>(documentSnapshot: documentSnapshot, codingPath: codingPath + [key], userInfo: userInfo))
    }

    func nestedUnkeyedContainer(forKey key: Key) throws -> UnkeyedDecodingContainer {
        guard let value = try primativeValue(forKey: key) as? [Any] else {
            throw DecodingError.typeMismatch([Any].self, DecodingError.Context(codingPath: codingPath, debugDescription: "Unexpected type for key \(key)"))
        }
        return DocumentSnapshotUnkeyedDecodingContainer(documentSnapshot: documentSnapshot, codingPath: codingPath + [key], userInfo: userInfo, count: value.count, isAtEnd: value.isEmpty, currentIndex: 0)
    }

    func superDecoder() throws -> Decoder {
        throw FiremodelError.internalError
    }

    func superDecoder(forKey key: Key) throws -> Decoder {
        throw FiremodelError.internalError
    }
}


// MARK: - Protocols

// MARK: - Standard Types

struct GeoPoint {
    let latitude: Float
    let longitude: Float
}

